# 数据一致性

Q，当用redis做mysql的缓存的时候，先更新数据库还是先更新redis？





**由于引入了缓存，那么在数据更新时，不仅要更新数据库，而且要更新缓存，这两个更新操作存在前后的问题**：

- 先更新数据库，再更新缓存；
- 先更新缓存，再更新数据库；

 

其实导致数据不一致的主要问题：<font color=red>**并发问题；**</font>



这几个概念很重要；

**数据库和redis是不同的系统不能保证原子性，所以会导致数据不一致的问题；**   



**php多进程确实也会存在整个问题**  **这里的数据库和redis相当于共享资源；多个进程对共享资源操作的时候会存在竞争的问题；**



**php 多进程里面没有共享资源；比如他的全局变量都是只有自己的进程才能访问到，所以php内部不存在一个进程的共享资源的问题；**

**那么只能存在于外部，比如redis 和 mysql；**



**但是要知道的是，在php中因为一个请求就是进程，没有线程的概念（只有一个线程）所以不存在同一个进程内对全局变量和静态变量（共享内存的竞争）；**



**可以使用分布式锁（redis分布式锁）来解决这个问题；**





**都会导致数据不一致的问题；**

**先更新缓存再执行数据库；**







**先更新缓存然后更新数据库**





**先更新数据库还是先删除缓存？**

不更新数据库，而是删除缓存中的数据，然后读数据时，发下缓存中没了数据之后，再从数据库中读数据，更新到缓存；



**先删除缓存然后再更新数据库**

 因为**数据库更新比较慢**，所以是有可能导致 缓存和数据库不一致的问题；

![图片](数据一致性.assets/640.png)

**先更新数据库，再删除缓存；**

**因为缓存的写入通常要远远快于数据库的写入**，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapiaHwGD4OYARxHTUqRctZyWPyEsGeiaMTWvjDS42t0zsI8Qk2eicdntySw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



**「先更新数据库，再删除缓存」**的方案虽然保证了数据库与缓存的数据一致性，但是每次更新数据的时候，缓存的数据都会被删除，这样会对缓存的命中率带来影响。 最好加一个过期时间；



所以，**如果我们的业务对缓存命中率有很高的要求，我们可以采用「更新数据库 + 更新缓存」的方案，因为更新缓存并不会出现缓存未命中的情况**。

但是这个方案前面我们也分析过，在两个更新请求并发执行的时候，会出现数据不一致的问题，因为更新数据库和更新缓存这两个操作是独立的，而我们又没有对操作做任何并发控制，那么当两个线程并发更新它们的话，就会因为写入顺序的不同造成数据的不一致。

所以我们得增加一些手段来解决这个问题，这里提供两种做法：

- **在更新缓存前先加个分布式锁，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。**
- **在更新完缓存时，给缓存加上较短的过期时间，这样即时出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的。**
- 

对了，针对「先删除缓存，再删除数据库」方案在「读 + 写」并发请求而造成缓存不一致的解决办法是「**延迟双删**」。

延迟双删实现的伪代码如下：

```
#删除缓存
redis.delKey(X)
#更新数据库
db.update(X)
#睡眠
Thread.sleep(N)
#再删除缓存
redis.delKey(X)
```

**加了个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。**

所以，请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。

但是具体睡眠多久其实是个**玄学**，很难评估出来，所以这个方案也只是**尽可能**保证一致性而已，极端情况下，依然也会出现缓存不一致的现象。

因此，还是比较建议用「先更新数据库，再删除缓存」的方案。