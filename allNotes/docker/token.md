# token

> token鉴权 

**token如何实现鉴权？**

第一步当登录之后，生成token，一般保存服务器硬盘，一般保存在服务器的数据库；

第二步 后面的所有请求（请求头）都会带上这个token，和服务器内的token进行对比；



**加密**

使用的是不可逆加密，只要暴漏信息要用不可逆的加密方式；md5 sha1 



**SIGN 签名**



token比session的优势，更节省资源，不需要去管理sessionid；



https://www.jianshu.com/p/8f7009456abc





token需要解决的问题 ，还有一些比较好的论文；

https://blog.51cto.com/u_14861909/5441613





https://www.cnblogs.com/yuki-nana/p/14001600.html



##  token 可以防止csrf攻击的原因；



Cookie  有一个过期时间，在这段时间内，Cookie 是存储在客户端的，当再次访问相同的网站时，浏览器会自动在 HTTP 请求中自动带上该网站用户登录后的 Cookie

CSRF 攻击也正是利用这点，借用用户的 Cookie，去执行非用户本意的操作

而 token 验证的规则是，服务器从请求体（POST）或者请求参数（GET）中获取设置的 token，然后和 Cookie 中的 token 进行比较，一致之后才执行请求

<font color=red>**而 CSRF 攻击只是借用了 Cookie，并不能获取 Cookie 中的信息，所以不能获取 Cookie 中的 token，也就不能在发送请求时在 POST 或者 GET 中设置 token，把请求发送到服务器端时，token 验证不通过，也就不会处理请求了**</font>

所以，token 可以防止 CSRF 攻击



**Token被用户端放在Cookie中（不设置HttpOnly），同源页面每次发请求都在请求头或者参数中加入Cookie中读取的Token来完成验证。CSRF只能通过浏览器自己带上Cookie，不能操作Cookie来获取到Token并加到http请求的参数中。**

**所以CSRF本质原因是“重要操作的所有参数都是可以被攻击者猜测到的”，Token加密后通过Cookie储存，只有同源页面可以读取，把Token作为重要操作的参数，CSRF无法获取Token放在参数中，也无法仿造出正确的Token，就被防止掉了。**



#### **Token 和 JWT 的区别**

**相同：**

- 都是**访问资源的令牌**
- 都可以**记录用户的信息**
- 都是**使服务端无状态化**
- 都是**只有验证成功**后，**客户端才能访问服务端上受保护的资源**

**区别：**

- Token：服务端验证客户端发送过来的 Token 时，**还需要查询数据库获取用户信息**，然后验证 Token 是否有效。
- JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，**不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。**



作者：bestCindy
链接：https://www.jianshu.com/p/240508e17ee4
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。













# [Cookie、Session、Token与JWT(跨域认证)](https://www.cnblogs.com/HighnessDragonfly/p/15244080.html)

之前看到群里有人问JWT相关的内容，只记得是token的一种，去补习了一下，和很久之前发的认证方式总结的笔记放在一起发出来吧。

# Cookie、Session、Token与JWT(跨域认证)

### 什么是Cookie？

- **HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，\**\**服务端不会保存任何会话信息**）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行**会话跟踪**（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而**这个状态需要通过 cookie 或者 session 去实现。**
- **cookie 存储在客户端：** cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
- **cookie 是\**\*\*不可跨域\*\**\*的：** 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，**一级域名和二级域名之间是允许共享使用的**（**靠的是 domain）**。

![图片](https://img2020.cnblogs.com/blog/2156235/202109/2156235-20210908182408208-1913437941.png)

### **什么是 Session**

- **session 是另一种记录服务器和客户端会话状态的机制**，即告诉服务端前后两个请求是否来自同一个客户端（浏览器），知道谁在访问我。**因为http本身是无状态协议**，这样，无法确定你的本次请求和上次请求是不是你发送的。如果要进行类似论坛登陆相关的操作，就实现不了了。
- **session 是基于 cookie 实现的，\**\*\*session 存储在服务器端\*\**\*，\**\**sessionId 会被存储到客户端的cookie 中**。ps：还有一种是浏览器禁用了cookie或不支持cookie，这种可以通过URL重写的方式发到服务器；

![图片](https://img2020.cnblogs.com/blog/2156235/202109/2156235-20210908182408085-260120114.png)

- 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，**创建对应的 Session**
- 请求返回时将此 Session 的**唯一标识信息 SessionID** 返回给浏览器。
- 浏览器接收到服务器返回的 SessionID 信息后，会**将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名** 。
- **当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息**，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

### **Cookie 和 Session 的区别**

- **安全性：**Session 是存储在服务器端的，Cookie 是存储在客户端的。所以 Session 相比 Cookie 安全，
- **存取值的类型不同**：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
- **有效期不同：** Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
- **存储大小不同：** 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

### Token

请求方输入自己的用户名，密码，然后 server 据此生成 token，客户端拿到 token 后会保存到本地（token存储在浏览器端），之后向 server 请求时在请求头带上此 token 即可（server有校验机制，检验token合法性，同时server通过token中携带的uid确定是谁在访问它）。

![图片](https://img2020.cnblogs.com/blog/2156235/202109/2156235-20210908182408114-1343163830.png)

可以看到 token 主要由三部分组成：

- header：指定了签名算法
- payload：可以指定用户 id，过期时间等非敏感数据
- Signature: 签名，server 根据 header 知道它该用哪种签名算法，再用密钥根据此签名算法对 head + payload 生成签名，这样一个 token 就生成了。

#### 优点：

- **只要 server 保证密钥不泄露，那么生成的 token 就是安全的，因为如果伪造 token 的话在签名验证环节是无法通过的，就此即可判定 token 非法。节省了服务器空间。**
- **支持跨域访问，cookie不支持， Cookie 跨站是不能共享的，这样的话如果你要实现多应用（多系统）的单点登录（SSO）。**
- **token是无状态的，可以在多个服务器间共享。**

#### 缺点：

token 一旦由 server 生成，它就是有效的，直到过期，无法让 token 失效，存储在客户端本地，容易被获取。

长度过长，超过cookie上限。

### JWT

**相当于自包含解密后的内容的token，服务端直接解密鉴权即可，不需要和数据库的token签名做比对。**

#### **JWT 认证流程：**

- 用户输入用户名/密码登录，**服务端认证成功后，会返回给客户端一个 JWT**
- 客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）
- 当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样

```plain
Authorization: Bearer <token>
```

- 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。
- 因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要。
- <font color=red>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）。</font>
- <font color=red>因为用户的状态不再存储在服务端的内存中，所以这是一种**无状态的认证机制。**</font>



#### **Token 和 JWT 的区别**

**相同：**

- 都是**访问资源的令牌**
- 都可以**记录用户的信息**
- 都是**使服务端无状态化**
- 都是**只有验证成功**后，**客户端才能访问服务端上受保护的资源**

**区别：**

- Token：服务端验证客户端发送过来的 Token 时，**还需要查询数据库获取用户信息**，然后验证 Token 是否有效。
- JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，**不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。**

### **使用 cookie 时需要考虑的问题**

- 因为存储在客户端，容易被客户端篡改，**使用前需要验证合法性**，所以，**不要存储敏感数据**，比如用户密码，账户余额；使用 **httpOnly** 在一定程度上提高安全性
- **尽量减少 cookie 的体积**，能存储的数据量不能超过 4kb；一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie
- 设置正确的 domain 和 path，减少数据传输
- **cookie 无法跨域**（每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用）
- **移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token**

### **使用 session 时需要考虑的问题**

- 将 session 存储在服务器里面，**当用户同时在线量比较多时**，这些 session 会占据较多的内存，需要**在服务端定期的去清理过期的 session**
- 当网站采用**集群部署**的时候，会遇到**多台 web 服务器之间如何做 session 共享的问题**。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。**解决方案**：写客户端cookie的方式、服务器之间session数据同步、用mysql数据库共享session数据。
- 当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在**各个应用做好 cookie 跨域的处理**。
- **sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？** 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现
- **移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token**
- 

### **使用 token 时需要考虑的问题**

- 如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。
- **token 完全由应用管理，所以它可以避开同源策略**  ?????
- **token 可以避免 CSRF 攻击(因为不需要 cookie 了)**
- **移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token**



### **使用 JWT 时需要考虑的问题**

- 因为 **JWT 并不依赖 Cookie** 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）
- JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
- JWT 不加密的情况下，不能将秘密数据写入 JWT。
- JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
- **JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展**。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此**使用过程中无法废弃某个 Token 或者更改 Token 的权限。**也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。
- **JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限**。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
- **JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT**，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。
- **为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。**

[好文要顶](javascript:void(0);) [关注我](javascript:void(0);) [收藏该文](javascript:void(0);) [![img](https://common.cnblogs.com/images/icon_weibo_24.png)](javascript:void(0);) [![img](https://common.cnblogs.com/images/wechat.png)](javascript:void(0);)
