# 查询构造器

>查询构造器；

----

## 取数据的构造器  ---以及结果的数据格式！！！

> **在laravel中每一条记录都是一个对象；这里需要注意一下；访问记录需要通过来访问；也可以通过 foreach 来遍历；**
>
> **get();  是一个二维数组，每条记录都是一个对象；**
>
> **就是默认返回的数据类型是FETCH_OBJ ;**

`````php
class PdoStatement implements  Iterator 
{
    protected $items = [];  // 每条记录的数据对象都保存在这个数组内；// 然后这个对象都是可以保存的；
    
}
`````

![image-20231229090259071](./%E6%9F%A5%E8%AF%A2%E6%9E%84%E9%80%A0%E5%99%A8.assets/image-20231229090259071.png)

first();  就取一条数据，

find();根据id 来取数据；

pluck()；取某一列的数据；并且是一个数组；

value();   用于单个值查询；

````php
在Laravel中，查询构造器中的value和pluck方法都用于从数据库中检索单个字段的值，但它们之间有一些区别。

//value方法用于检索指定字段的单个值，并返回该值作为标量。例如：

$name = DB::table('users')->where('id', 1)->value('name');
上面的代码将返回id为1的用户的名字作为一个字符串。

//pluck方法用于检索指定字段的值，并返回一个由这些值组成的集合。例如：
$names = DB::table('users')->pluck('name');
上面的代码将返回所有用户的名字，并将它们作为一个集合返回。

因此，value方法返回单个标量值，而pluck方法返回一个包含指定字段值的集合。
````



`````php
// 为啥 取获取的数据对象可以用foreach 来遍历；
//因为实现了Iterator 接口  和 聚合迭代器；(了解一下；)

<?php
class myData implements IteratorAggregate {
    public $property1 = "Public property one";
    public $property2 = "Public property two";
    public $property3 = "Public property three";
    public $property4 = "";

    public function __construct() {
        $this->property4 = "last property";
    }

    public function getIterator(): Traversable {
        return new ArrayIterator($this);
    }
}

$obj = new myData;

foreach($obj as $key => $value) {
    var_dump($key, $value);
    echo "\n";
}
?>
`````

----

**pdo 做一下预算；**

去看pdo 篇章 就可以了 ，就是默认返回的数据类型是FETCH_OBJ ;

---



## DB::table('table_name') 表名

返回一个表的对象；

## get()；获取所有的数据

select * from t；

## pluck

DB::table('t')->pluck('name');

##first()

select * from t limit 1;

## select();

DB::table()->select()->get();select 来声明字段名；

## where

从数据表中获取单行或单列
如果你只需要从数据表中获取一行数据，你可以使用 first 方法。该方法返回一个 stdClass 对象：

$user = DB::table('users')->where('name', 'John')->first();

echo $user->name;
如果你甚至不需要整行数据，则可以使用 value 方法从记录中获取单个值。该方法将直接返回该字段的值：

**$email = DB::table('users')->where('name', 'John')->value('email');**
如果是通过 id 字段值获取一行数据，可以使用 find 方法：

**$user = DB::table('users')->find(3);**  //id = 3 的数据；



````php
简单的 Where 语句
在构造 where 查询实例中，你可以使用 where 方法。调用 where 最基本的方式是需要传递三个参数：第一个参数是列名，第二个参数是任意一个数据库系统支持的运算符，第三个是该列要比较的值。

例如，下面是一个要验证 「votes」 字段的值等于 100 的查询：

$users = DB::table('users')->where('votes', '=', 100)->get();
为了方便，如果你只是简单比较列值和给定数值是否相等，可以将数值直接作为 where 方法的第二个参数：

$users = DB::table('users')->where('votes', 100)->get();
当然，你也可以使用其他的运算符来编写 where 子句：

$users = DB::table('users')
                ->where('votes', '>=', 100)
                ->get();

$users = DB::table('users')
                ->where('votes', '<>', 100)
                ->get();

$users = DB::table('users')
                ->where('name', 'like', 'T%')
                ->get();
你还可以传递条件数组到 where 函数中：
//多个where条件；
$users = DB::table('users')->where([
    ['status', '=', '1'],
    ['subscribed', '<>', '1'],
])->get();

//whereNull  // 判断是否是null 本质就是is null;
//orWhere // 条件之间用 or 连接；
//了解一下 嵌套问题；
$users = DB::table('users')
            ->where('name', 'John')
            ->where(function($query) {
                $query->where('age', '>', 30)
                      ->orWhere('gender', 'Female');
            })
            ->get();
````



## raw

````php
//
DB::raw();  //原生的sql语句；

//在Laravel中，raw方法允许你在查询中使用原始的SQL语句。这在需要执行复杂的数据库操作或者使用特定数据库的功能时非常有用。

你可以在查询构造器中使用raw方法来添加原始的SQL语句，如下所示：

$users = DB::table('users')
            ->select(DB::raw('count(*) as user_count, status'))
            ->where('status', 1)
            ->groupBy('status')
            ->get();
//在上面的示例中，DB::raw方法允许我们在select方法中使用原始的SQL语句来计算用户数量，并将其作为user_count返回。

//另一个常见的用法是在where方法中使用raw来添加复杂的条件，如下所示：
## whereRaw();

$users = DB::table('users')
            ->whereRaw('age > ? and status = ?', [30, 'active'])
            ->get();
//在上面的示例中，我们使用whereRaw方法来添加一个包含占位符的原始SQL条件，并提供占位符的值作为第二个参数。

//通过使用raw方法，你可以在Laravel中执行原始的SQL语句，从而实现更灵活和复杂的数据库操作。




//各种raw
    
可以使用以下方法代替 DB::raw，将原生表达式插入查询的各个部分。

selectRaw
selectRaw 方法可以代替 select(DB::raw(...))。该方法的第二个参数是可选项，值是一个绑定参数的数组：

$orders = DB::table('orders')
                ->selectRaw('price * ? as price_with_tax', [1.0825])
                ->get();
whereRaw / orWhereRaw
whereRaw 和 orWhereRaw 方法将原生的 where
注入到你的查询中。这两个方法的第二个参数还是可选项，值还是绑定参数的数组：

$orders = DB::table('orders')
                ->whereRaw('price > IF(state = "TX", ?, 100)', [200])
                ->get();
havingRaw / orHavingRaw
havingRaw 和 orHavingRaw 方法可以用于将原生字符串设置为 having 语句的值：

$orders = DB::table('orders')
                ->select('department', DB::raw('SUM(price) as total_sales'))
                ->groupBy('department')
                ->havingRaw('SUM(price) > ?', [2500])
                ->get();
orderByRaw
orderByRaw 方法可用于将原生字符串设置为 order by 语句的值：

$orders = DB::table('orders')
                ->orderByRaw('updated_at - created_at DESC')
                ->get();
groupByRaw
groupByRaw 方法可以用于将原生字符串设置为 group by 语句的值：

$orders = DB::table('orders')
                ->select('city', 'state')
                ->groupByRaw('city, state')
                ->get();

````

## Or 语句



```````php
Or 语句
你可以一起链式调用 where 约束，也可以在查询中添加 or 字句。orWhere 方法和 where 方法接收的参数一样：

$users = DB::table('users')
                    ->where('votes', '>', 100)
                    ->orWhere('name', 'John')
                    ->get();
如果需要在括号内对 or 条件进行分组，将闭包作为 orWhere 方法的第一个参数也是可以的：

$users = DB::table('users')
            ->where('votes', '>', 100)
            ->orWhere(function($query) {
                $query->where('name', 'Abigail')
                      ->where('votes', '>', 50);
            })
            ->get();

// SQL语句: select * from users where votes > 100 or (name = 'Abigail' and votes > 50)
```````



## whereBetween whereIn

``````php
附加 Where 语句
//whereBetween / orWhereBetween

whereBetween 方法验证字段值是否在给定的两个值之间：

$users = DB::table('users')
           ->whereBetween('votes', [1, 100])
           ->get();
//whereNotBetween / orWhereNotBetween

whereNotBetween 方法用于验证字段值是否在给定的两个值之外：

$users = DB::table('users')
                    ->whereNotBetween('votes', [1, 100])
                    ->get();
//whereIn / whereNotIn / orWhereIn / orWhereNotIn

whereIn 方法验证给定列的值是否包含在给定数组中：

$users = DB::table('users')
                    ->whereIn('id', [1, 2, 3])
                    ->get();
whereNotIn 方法验证给定列的值是否不存在给定的数组中：

$users = DB::table('users')
                    ->whereNotIn('id', [1, 2, 3])
                    ->get();
技巧：如果要在查询中添加大量整数绑定，则可以使用 whereIntegerInRaw 或 whereIntegerNotInRaw 方法来大大减少内存使用。

whereNull / whereNotNull / orWhereNull / orWhereNotNull

whereNull 方法验证指定的字段必须是 NULL:

$users = DB::table('users')
                    ->whereNull('updated_at')
                    ->get();
whereNotNull 方法验证指定的字段肯定不是 NULL:

$users = DB::table('users')
                    ->whereNotNull('updated_at')
                    ->get();
whereDate / whereMonth / whereDay / whereYear / whereTime

whereDate 方法用于比较字段值与给定的日期（年月日）：

$users = DB::table('users')
                ->whereDate('created_at', '1989-01-09')
                ->get();
whereMonth 方法可用于将字段值与一年中的特定月份进行比较：

$users = DB::table('users')
                ->whereMonth('created_at', '01')
                ->get();
whereDay 方法可用于将字段值与一个月中的几号进行比较：

$users = DB::table('users')
                ->whereDay('created_at', '09')
                ->get();
whereYear 方法用于比较字段值与指定的年份：

$users = DB::table('users')
                ->whereYear('created_at', '1989')
                ->get();
whereTime 方法用于比较字段值与指定的时间（时分秒）:

$users = DB::table('users')
                ->whereTime('created_at', '=', '11:20:45')
                ->get();
whereColumn / orWhereColumn

whereColumn 方法用于比较两个字段的值是否相等：

$users = DB::table('users')
                ->whereColumn('first_name', 'last_name')
                ->get();
你也可以传入一个比较运算符:

$users = DB::table('users')
                ->whereColumn('updated_at', '>', 'created_at')
                ->get();
你也可以给 whereColumn 传递一个数组，他们之间会使用 and 运算符连接:

$users = DB::table('users')
                ->whereColumn([
                    ['first_name', '=', 'last_name'],
                    ['updated_at', '>', 'created_at'],
                ])->get();
``````



## chunk 分块处理？？

如果你需要处理上千上万条数据库记录，你可以考虑使用 chunk 方法。该方法每次获取结果集的一小块，并将其传递给 Closure 函数进行处理。该方法在 Artisan 命令 中处理大量查询数据的时候非常有用。例如，我们可以将全部 users 表数据切割成一次处理 100 条记录的一小块：

````php
//1
DB::table('t')->oderBy('id')->chunk(100,function($users){
	foreach($users as $user) {
        //handle处理逻辑；
    }
});

//2  return false ，代表的是终止执行；
//你可以通过在 Closure 中返回 false 来终止继续获取分块结果：
DB::table('users')->orderBy('id')->chunk(100, function ($users) {
    // Process the records...

    return false;
});

//3
//如果要在分块结果中更新数据库记录，则块结果可能会和预计的返回结果不一致。 因此，在分块更新记录时，最好使用 chunkById 方法。 此方法将根据记录的主键自动对结果进行分页：
//把active = false 的记录，更改成true;
DB::table('users')->where('active', false)
    ->chunkById(100, function ($users) {
        foreach ($users as $user) {
            DB::table('users')
                ->where('id', $user->id)
                ->update(['active' => true]);
        }
    });
````



## 聚合

````php
DB::table('name')->count();
DB::table('name')->max('price');

$price = DB::table('orders')
                ->where('finalized', 1)
                ->avg('price');
````



## 判断记录是否存在

````php
return DB::table('orders')->where('finalized', 1)->exists();

return DB::table('orders')->where('finalized', 1)->doesntExist();
````



## JOIN

`````php
//join  -- 看看基础的就好了呀；
#Inner Join 语句
查询构造器也可以编写 join 方法。若要执行基本的「内链接」，你可以在查询构造器实例上使用 join 方法。传递给 join 方法的第一个参数是你需要连接的表的名称，而其他参数则使用指定连接的字段约束。你还可以在单个查询中连接多个数据表：

$users = DB::table('users')
            ->join('contacts', 'users.id', '=', 'contacts.user_id')
            ->join('orders', 'users.id', '=', 'orders.user_id')
            ->select('users.*', 'contacts.phone', 'orders.price')
            ->get();
#Left Join / Right Join 语句
如果你想使用 「左连接」或者 「右连接」代替「内连接」 ，可以使用 leftJoin 或者 rightJoin 方法。这两个方法与 join 方法用法相同：

$users = DB::table('users')
            ->leftJoin('posts', 'users.id', '=', 'posts.user_id')
            ->get();

$users = DB::table('users')
            ->rightJoin('posts', 'users.id', '=', 'posts.user_id')
            ->get();
## ------------------------------------------------------------------------------------------------------------------
Cross Join 语句
使用 crossJoin 方法和你想要连接的表名做「交叉连接」。交叉连接在第一个表和被连接的表之间会生成笛卡尔积:

$sizes = DB::table('sizes')
            ->crossJoin('colors')
            ->get();
高级 Join 语句
 ###    -----------------------------------------------------------------------------------------------------
你可以指定更高级的 join 语句。比如传递一个闭包作为 join 方法的第二个参数。此闭包接收一个 JoinClause 对象，从而指定 join 语句中指定的约束：

DB::table('users')
        ->join('contacts', function ($join) {
            $join->on('users.id', '=', 'contacts.user_id')->orOn(...);
        })
        ->get();
如果你想要在连接上使用「where」 风格的语句，你可以在连接上使用 where 和 orWhere 方法。这些方法会将列和值进行比较，而不是列和列进行比较：

DB::table('users')
        ->join('contacts', function ($join) {
            $join->on('users.id', '=', 'contacts.user_id')
                 ->where('contacts.user_id', '>', 5);
        })
        ->get();
###---------------------------------------------------------------------
子连接查询
你可以使用 joinSub，leftJoinSub 和 rightJoinSub 方法关联一个查询作为子查询。他们每一种方法都会接收三个参数：子查询，表别名和定义关联字段的闭包：

$latestPosts = DB::table('posts')
                   ->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))
                   ->where('is_published', true)
                   ->groupBy('user_id');

$users = DB::table('users')
        ->joinSub($latestPosts, 'latest_posts', function ($join) {
            $join->on('users.id', '=', 'latest_posts.user_id');
        })->get();

`````

## 子查询

````php
````



## UNION

````php

//查询构造器还提供了将两个查询「联合」的快捷方式。比如，你可以先创建一个查询，然后使用 union 方法将其和第二个查询进行联合：

$first = DB::table('users')
            ->whereNull('first_name');

$users = DB::table('users')
            ->whereNull('last_name')
            ->union($first)  // union查询的联合；
            ->get();

````



## orderBy

>oderBy('name',desc);

````php
//orderBy 方法允许你通过给定字段对结果集进行排序。 orderBy 的第一个参数应该是你希望排序的字段，第二个参数控制排序的方向，可以是 asc 或 desc：

$users = DB::table('users')
                ->orderBy('name', 'desc')
                ->get();
//如果你需要使用多个字段进行排序，你可以多次引用 orderBy：

$users = DB::table('users')
                ->orderBy('name', 'desc')
                ->orderBy('email', 'asc')
                ->get();
````



## groupBy

````php
groupBy / having
//groupBy 和 having 方法用于将结果分组。 having 方法的使用与 where 方法十分相似：

$users = DB::table('users')
                ->groupBy('account_id')
                ->having('account_id', '>', 100)
                ->get();
//你可以向 groupBy 方法传递多个参数，来对结果使用多个字段进行分组：

$users = DB::table('users')
                ->groupBy('first_name', 'status')
                ->having('account_id', '>', 100)
                ->get();
对于更高级的 having 语法，参见 havingRaw 方法。
````



## limit  offset

`````php
//或者你也可以使用 limit 和 offset 方法：
$users = DB::table('users')
                ->offset(10)  // 先找偏移量 
                ->limit(5)    // 数据的数量；
                ->get();

//skip / take  一样 skip == offset limit == take ; 取多少条数据；
要限制结果的返回数量，或跳过指定数量的结果，你可以使用 skip 和 take 方法：

$users = DB::table('users')->skip(10)->take(5)->get();


`````



## 插入

````php
//insert 插入；
//查询构造器还提供了 insert 方法用于插入记录到数据库中。 insert 方法接收数组形式的字段名和字段值进行插入操作：

DB::table('users')->insert(
    ['email' => 'john@example.com', 'votes' => 0]
);
//你甚至可以将二维数组传递给 insert 方法，依次将多个记录插入到表中：

DB::table('users')->insert([
    ['email' => 'taylor@example.com', 'votes' => 0],
    ['email' => 'dayle@example.com', 'votes' => 0],
]);
//insertOrIgnore 方法在将记录插入数据库时将忽略重复记录错误：

DB::table('users')->insertOrIgnore([
    ['id' => 1, 'email' => 'taylor@example.com'],
    ['id' => 2, 'email' => 'dayle@example.com'],
]);

````



## 自增 IDs
如果数据表有自增 ID ，使用 insertGetId 方法来插入记录可以返回 ID 值：

`````php
//小驼峰，insertGetId();
$id = DB::table('users')->insertGetId(
    ['email' => 'john@example.com', 'votes' => 0]
);
`````



##   更新
当然， 除了插入记录到数据库中，查询构造器也可以通过 update 方法更新已有的记录。 update 方法和 insert 方法一样，接受包含要更新的字段及值的数组。你可以通过 where 子句对 update 查询进行约束：

````php
//数据的更新；
$affected = DB::table('users')
              ->where('id', 1)
              ->update(['votes' => 1]);
````



##更新 JSON 字段
更新 JSON 字段时，你可以使用 -> 语法访问 JSON 对象中相应的值。注意，此操作只能支持 MySQL 5.7+ 和 PostgreSQL 9.5+ ：

`````php
//JSON 数据类型的更新；
$affected = DB::table('users')
              ->where('id', 1)
              ->update(['options->enabled' => true]);


`````



## 自增与自减
查询构造器还为给定字段的递增或递减提供了便捷的方式。此方法提供了一个比手动编写 update 语句更具表达力且更精练的接口。

这两种方法都至少接收一个参数：需要修改的列。可选的第二个参数用于控制列递增或递减的量：

`````php
DB::table('users')->increment('votes');

DB::table('users')->increment('votes', 5);

DB::table('users')->decrement('votes');

DB::table('users')->decrement('votes', 5);
`````

你也可以在操作过程中指定要更新的其他字段：

````php
DB::table('users')->increment('votes', 1, ['name' => 'John']);
````





## 删除
查询构造器也可以使用 delete 方法从表中删除记录。 在使用 delete 前，可以添加 where 子句来约束 delete 语法：

````php
DB::table('users')->delete();

DB::table('users')->where('votes', '>', 100)->delete();
````


您可以使用 truncate 方法来清空整个表，这将移除所有的数据并重置所有的自增 ID 为 0 ：

````php
DB::table('users')->truncate();
````



##悲观锁

> shareLock(); //乐观锁；
>
>lockForUpdate():悲观锁；

查询构造器也包含了一些能够帮助您在 select 语句中实现「悲观锁」的函数。要执行一个含有「共享锁」的语句，您可以在查询中使用 sharedLock 方法。共享锁可防止指定的数据列被篡改，直到事务被提交为止：

`````php
DB::table('users')->where('votes', '>', 100)->sharedLock()->get();
`````


或者，您亦可使用 lockForUpdate 方法。使用「 update 」锁可以避免数据行被其他共享锁修改或选定：

`````php
DB::table('users')->where('votes', '>', 100)->lockForUpdate()->get();
`````





## 调试
在绑定查询的时候，您可以使用 dd 或 dump 方法来输出查询绑定和 SQL。dd 方法将会显示调试信息并终止执行请求，而 dump 方法则会显示调试信息并允许请求继续执行：

`````php
//   //dbeug 调试；  // 只有在对builder 对象的时候才可以进行 debug 调试；
DB::table('users')->where('votes', '>', 100)->dd();  // 这边是输出sql 并且停止往下运行，并不会输出 结果；

DB::table('users')->where('votes', '>', 100)->dump(); // 输出sql 并且输出结果；
`````
