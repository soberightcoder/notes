# 生命周期

>**把http请求封装成一个Request对象；**
>
>**//todo  kernel 内核是什么意思？所有的一切都是由kernel内核去执行；**



![image-20231226202805098](./%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.assets/image-20231226202805098.png)



---

## 生命周期

1. **Laravel 应用的所有请求入口都是 `public/index.php` 文件。而所有的请求都是经由你的 Web 服务器（Apache/Nginx）通过配置引导到这个文件。**

`````php
#index.php 分为两部分
1. 自动加载；
2. 创建服务容器；app
`````



2. **创建服务容器App,注册kernel内核（可以通过bootstraps 来加载基础的环境配置；），命令kernel，加异常处理类，并并且通过app.php 来加载服务提供者；服务提供者里面的方法register来来给服务容器注册实例；****

   下面都交给kernel来处理；

3. kernel 将http请求封装成Requset对象；

4. kernel设置请求的前置中间件；（请求的控制；）（配置信息是在kernel.php Middleware 数组内；）

5. 路由分发； **请求分发；**

6. 控制器（处理你的业务逻辑；）  

7. return 生成Reponse对象；

8. 后置中间件；-- 对reponse对象的处理；

9. web

![image-20231228114651129](./%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.assets/image-20231228114651129.png)

下面没有显示出来的部分分别是路由+ 控制器；

![image-20231228115618974](./%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.assets/image-20231228115618974.png)



---

## 类的别名机制；

>//todo  去看一下和门面有啥关系；

**app.php   alias这个数组是啥意思？？为了方便facade 去取数据吗？**
**一般和getaccessor 一个名字把；**

在Laravel的`app.php`配置文件中，`aliases`数组用于定义类的别名，也就是为类创建简短的别名，以便在应用程序中更方便地引用这些类。

当你在`aliases`数组中定义了一个类的别名后，你就可以在应用程序的任何地方使用这个别名来引用这个类，而不必使用完整的类名。这样可以使代码更加简洁和易读。

例如，假设你在`aliases`数组中定义了以下别名：

```
CopyOpen'aliases' => [
    'MyClass' => App\MyNamespace\MyClass::class,
],
```

然后在应用程序的任何地方，你都可以使用`MyClass`来引用`App\MyNamespace\MyClass`，如下所示：

```
CopyOpen
$instance = new MyClass();
```

这样可以避免在代码中重复使用完整的类名，提高了代码的可读性和可维护性。

总之，`aliases`数组提供了一种在应用程序中定义类别名的机制，使得在代码中引用类时更加简洁和方便。

---

## Route

**路由本质就是 uri 和 类名之间的映射关系；类名是包含，命名空间的；**

**通过类名 去加载 类（require_once），是通过 自动加载去实现的；**



## 异常处理 Exception handler

 所有的异常

![image-20231228114130986](./%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.assets/image-20231228114130986.png)



---

## kernel 做了什么？？？

![image-20231228120231417](./%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.assets/image-20231228120231417.png)
