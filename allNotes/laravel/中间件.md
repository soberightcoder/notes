# 中间件的概念和用途 和使用 ；

---

>**中间件 就是对web应用程序对http请求处理的一种机制；**
>
>**中间件可以用于对请求和响应进行操作和调整，从而允许你对请求进行适当的调整； 对请求和响应都是可以调整的；**
>
>**本质是一个责任链模式；**
>
>**http请求封装成Request；**

---

中间件通过一系列的中间堆栈来进行处理，一个中间件可以完成特定的请求处理行为，比如权限验证，API认证，CSRF-token验证 等操作，也可以对请求进行若干修改，比如添加请求头，修改响应等操作，或者对路由或者控制器进行访问控制；做一个拦截处理；



![image-20231226143045110](./%E4%B8%AD%E9%97%B4%E4%BB%B6.assets/image-20231226143045110.png)

![image-20231226224929820](./%E4%B8%AD%E9%97%B4%E4%BB%B6.assets/image-20231226224929820.png)



## 实现一个中间件；



![image-20231226203328855](./%E4%B8%AD%E9%97%B4%E4%BB%B6.assets/image-20231226203328855.png)

`````php

// 中间件的分类；---注意一下app/http/kernel.php 文件；配置全局路由
//第一种分类方式；  --- 可以去app/http/kernel.php 里面去配置；全局或者路由或者web api 中间件；
//全局中间件
//web.php api.php 的中间件；
// routemiddleware 路由中间件；

//也可以根据 处在路由的前面或者后面分为：
// 1. 前置路由中间件；
// 2. 后置路由中间件；


//首先要创建一个中间件；
php artisan make:middleware TestMiddleWare1
php artisan make:middleware TestMiddleWare2
//会在 app/http/middleware 下生成一个中间件； 注意里面的handle方法；

    <?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;

class TestMiddleWare2
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure(\Illuminate\Http\Request): (\Illuminate\Http\Response|\Illuminate\Http\RedirectResponse)  $next
     * @return \Illuminate\Http\Response|\Illuminate\Http\RedirectResponse
     */
    public function handle(Request $request, Closure $next)
    {
          //路由的前置中间件；
          dump("testmiddleware2前置中间件；");
          $reponse = $next($request);
          //路由的后置中间件；
          dump("testmiddleware2后置中间件");
          return $reponse;
    }
}


/**
 * 中间件部分的路由
 *  几种请求方式；
 */

// Route::get('testmw1',function() {
//     echo "testmiddleware1";
// })->middleware('test1');

//上面的另外一种写法；

// Route::middleware('test1')->get('testmw1',function () {
//     echo "testmiddleware1";
// });

//一个请求多个中间件；
Route::middleware('test1','test2')->get('multimiddleware',function() {
    echo "multi middle ware";
});

// 组模式； 可以给一个路由添加中间件，另外一个不添加中间件；
Route::prefix('admin')->group(function() {
    Route::get('test1', function() {
        echo "admin/test1";
    });
    Route::get('test2', function() {
        echo "admin/test2";
    })->middleware('test1');
});

//给组内的所有路由添加中间件；

Route::middleware('test1')->group(function() {
    Route::get('grouptest1',function () {
        echo "group test1middleware";
    });
    Route::get('grouptest2',function () {
        echo "group test1middleware";
    });
});
`````



## 传统的请求控制的实现 -- 创建基类的方式

以前实现权限控制，或者对请求做一定的限制；我们框架也是，这种实现方式；

>**这种传统的请求控制的实现，需要在路由和控制器之间创建一个basecontroller ，消耗了路由资源；**

````php
//通过继承父类的方式来实现对请求的控制；继承父类的构造方法，来实现对请求的控制；

class BaseController
{
    public function __construct() {
        $this->verify();
    }
    
    public function verify() {
        echo "doing verify!!";
    }
}

class UserController
{
     public function __construct() {
         parent::__construct();  // 
     }
}

### eg: -----------------------------------------------------------------------------------------------------------

echo "\n";
//以前的请求控制使用的方法就是创建一个基础控制器；

class BaseController
{
    public function __construct() {
        $this->verify();
    }

    public function verify() {
        echo "do verify!!";
        echo "\n";
        echo "do requeset control";
    }
}

class UserController extends BaseController
{
    public function __construct() {
        parent::__construct();
    }

    public function handle() {
        echo "do user operation";
    }
}

$obj = new UserController;
$obj->handle();

### res
//do verify!!
//do requeset controlldo user operation
````





---





## 实现一个中间件

```php
//
```



---

## 随便写一个责任链模式把；

`````php
//以middleware来实现一个责任链模式；
`````

