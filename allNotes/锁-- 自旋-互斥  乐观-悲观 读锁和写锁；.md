#锁-- 自旋-互斥  乐观-悲观 读锁和写锁；

>多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。
>
>加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。
>
>我们不仅需要清楚知道**加锁的成本开销有多大**，还需要分析业务场景中**访问的共享资源的方式**，再来还要考虑**并发访问共享资源时的冲突概率**。
>
>线程的上下文切换的是什么？当两个线程是属于同一个进程，**因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**
>上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间

https://www.cnblogs.com/xiaolincoding/p/13675202.html





当一个线程加锁后，其他的线程就会加锁失败：

加索失败之后的处理不同分为自旋锁和互斥锁：
**互斥锁：会存在两次线程的上下文切换；（会进行线程切换；）**

- 当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；
- 接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。

**自旋锁：（忙等待；）**

就像去接水一样，当有人在接水，你可以使用去休息等人来通知你没人接水了（会存在两次的线程的切换；），或者你在那个人后面去排队，忙等待；

<font color=red>**由于*自旋锁*不会睡眠,*自旋锁*一直*占用cpu*,在未获得锁的情况下,一直运行,所以占用着cpu,如果不能在很短的时间内获得锁,这无疑会使CPU效率降低**</font >

**当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对**。

应用要求：

**如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。**





读锁和写锁：**读写锁在读多写少的场景，能发挥出优势**。

1. 当写锁没有被线程持有时，多个线程能够并发地持有读锁；
2. 一旦写锁被持有后，读写操作都会被阻塞；







悲观锁和乐观锁；

**前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。**



**冲突概率的问题 太高了不适合乐观锁；**

悲观锁做事比较悲观，它认为**多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁**。



乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作**。 **提交的时候进行一个验证；**



乐观锁虽然去除了加锁解锁的操作，**但是一旦发生冲突，重试的成本非常高**，所以**只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。**

