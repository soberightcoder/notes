# 有索引但是没有走索引





1. **没有遵从最左前缀原则**；
   * 联合索引
   * 模糊匹配 字符串的匹配
2. **存在隐式的数据类型转换**； 使用了函数；进行了计算num+1 =   数据类型不匹配的问题；
3. **走索引没有全表扫描的效率高**；一般是主键索引的全表扫描；
   * 回表效率太慢，可以使用using index 索引覆盖来解决这个问题；
   * using filesort；
   * 使用临时表；
   * limit 35000，10； 加where条件；他会取35010条数据 把前35000条数据去掉，只要这10条；



使用临时表的场合：需要去做一些操作，需要存储一下中间变量；


1. union （两个结果集的交集）一般回需要临时表来进行去重；如果是union all 就是不需要去重，不需要临时表，只需要一个结果集一个结果集的返回就可以了；
2. group by；
3. distinct；

这并不是临时表；


1. order by **使用的是filesort 外部索引来进行排序；**









**当然，<font color=red>扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</font>**



采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。

之前优化器选择使用索引 b，是因为它认为使用索引 b 可以避免排序（b 本身是索引，已经是有序的了，如果选择索引 b 的话，不需要再做排序，只需要遍历），所以即使扫描行数多，也判定为代价更小。

**mysql> explain select * from t where (a betwee**



**n 1 and 1000) and (b between 50000 and 100000) order by b limit 1;**

**会使用 b索引是不是；**

