# 正则(regular expression)

>正则表达式：regex；
>
>total:匹配<font color=red>有规律</font>的手机号，身份证号，匹配日志；
>
>应用场景：grep sed awk，过滤有规律的日志；一般这个比较常用；
>
>网站  regex101.com

**注意：**

*  所有的符号是英文符号；
* grep 命令 正则要加单引号；//
* alias grep=’grep --color=auto';<font color=red> export GREP_OPTIONS='--color=auto' GREP_COLOR='31'</font>
* 字符集问题export LANG=C

**正则符号：**

**基础正则：**

````bash
grep 'xxx' Regex.php 匹配有xxx的行；
^  ^... 以...开头的行；
$  ...$   以...结尾的行；
^$ 空白行(空格也没有) 空格也是一个字符串；grep -v "^$" regex.php 排除空行；
.  任意一个字符 .不匹配空行；
* 前一个字符连续出现0次或者0次以上；
\ 转译字符，脱掉马甲打回原形，去除原有特殊意义； \n  回车换行   \t tab键
.* 所有 任何的内容 空行也会匹配；

[a-z]  匹配中括号的任意一个字符；（a或b-z）或 [0-9a-zA-Z] [a-Z]  
[] 括号的特殊意义都会被抛弃； [a-Z0-9|] 就是匹配 0-9a-Z|

[^abc] 尖括号 在中括号  就是取反的意思； 匹配 abc以外的内容；  注意这里是[^abc] 除了这三个字符其他的字符都可以匹配
````

 **扩展符号：**

**注意**：扩展正则 需要用 **egrep** 或者使用 **grep -E**   或者 **下面的符号使用\转译的形式**；

`````bash
+ 前面一个字符连续出现1次或者1次以上；[0-9]+
| 或 满足任意一个都可以；[] 也表示或者 之间的区别：[] 一次匹配一个字符  | 可以一次匹配多个字符 一般在匹配一个单词的时候  al|ai|ce|ck
() 1.被括起来的内容，相当于是一个整体  2.反向引用（sed） \1 后向引用；    1.egrep 'oldb(o|e)y' filename
{} 连续出现  {n,m} >=n <=m 前面的字符至少连续出现了n次最多出现了m次； {n} ==m 就是出现了n次  {n,}>=n至少出现了n次  {,m}最多出现了m次 0-m <=n
? 前面一个字符出现0次或者1次；
`````

**正则VS通配符：**

**正则：**

用途：进行字符串的过滤； 

grep sed awk  preg_match_all();

**通配符：**

匹配文件名 *.txt   *.log  

linux 下的大部分命令都支持；



**正则匹配贪婪性** ：**尽可能多的去匹配**；

**\* 灵异现象 2* 会匹配所有  因为*是匹配0次或者0次以上；0次就是没有；**

**cat -A 显示隐藏的字符；**



匹配操作符

``````bash
\d 数字 [0-9]
\w [0-9a-Z_chinese] 匹配字母数字下划线汉字；
\s space 匹配一个空格
\b  匹配 一个单词  grep '\becho\b' test.txt
其实完全可以使用 grep -w 来实现
``````



grep -i igonorecase

 -o 显示过程

-v 反向匹配；

-n number 