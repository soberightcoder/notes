# 脚本的执行



**脚本执行的几种方式？**



* 将shell脚本作为参数传递给 Bash解释器 ；

  sh   -x     sh === bash    which sh   **-x 用来跟踪 	脚本的执行过程；用来排错**

  ````shell
  #bash 命令 不需要给权限；
  # 可以不用写 #!/bin/bash   
  # sh 就代表声明了解释器是bash；

* 将脚本作为程序运行     那么就需要给他权限 ；  chmod u+x ./ 路径的方式执行；

  ````shell
  #./表示当前目录，整条命令的意思是执行当前目录下的 test.sh 脚本。如果不写./，Linux 会到系统路径（由 PATH 环境变量指定）下查找 test.sh，而系统路径下显然不存在这个脚本，所以会执行失败。
  # 直接执行 会被当成 命令;
  # 需要声明用的解释器 #!/bin/bash
  [root@localhost shell]# check.sh
  -bash: check.sh: command not found 
  ````

* source命令   == .space  filename  

  ```shell
  . filename

* sh < check.sh 类似于 sh check.sh

### 检查是否开启了新的进程



````shell
echo $$

#code check.sh
#!/bin/bash
echo $$  # 输出当前进程的pid

#执行 1  u g o   r w x 
chmod u+x ./check.sh
#2
sh check.sh

#都会开启一个新的进程；
[root@localhost shell]# echo $$
3302
[root@localhost shell]# ./check.sh 
3401
[root@localhost shell]# sh check.sh 
3402


#source 不会开启一个新的进程；
[root@localhost shell]# check.sh
-bash: check.sh: command not found

#使用./ 运行脚本的时候，系统变量不会受到影响，而使用source的时候，会影响到系统当前的环境变量。 是否对当前系统产生影响；
#code check.sh
#!/bin/bash
echo $$  # 输出当前进程的pid
export ceshi=ceshi1
export | grep ceshi

. check.sh
[root@localhost shell]# export | grep ceshi
declare -x ceshi="ceshi1"

#sh check.sh ./check.sh 也可以执行；

[root@localhost shell]# echo $$
3302
[root@localhost shell]# ./check.sh 
3464
declare -x ceshi="ceshi1"
	
````

