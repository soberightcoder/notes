# average load  平均负载；





## uptime 

>查看cpu核数--- 
>
>**root@40558671ee3b:/var/www/html# grep "model name" /proc/cpuinfo | wc -l**
>**2**
>
>超过

uptime 单行显示以下信息。 当前时间、系统运行了多长时间、当前登录的用户数以及过去 1、5 和 15 分钟的系统负载平均值。           

**系统负载平均值是处于可运行或不可中断状态的平均进程数。**

 **处于可运行状态的进程要么正在使用 CPU，要么正在等待使用 CPU。 不间断的进程        状态正在等待一些 I/O 访问，例如等待磁盘。 取三个时间间隔的平均值。**

 负载平均值未针对系统中的 CPU 数量进行标准化，因此负载平均值为 1 表示单个 CPU        系统一直在加载，而在 4 CPU 系统上，这意味着它有 75% 的时间处于空闲状态。





###判断系统负荷是否过重，必须理解load average的真正含义。下面，我根据"[Understanding Linux CPU Load](http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages)"这篇文章，尝试用最通俗的语言，解释这个问题。

首先，假设最简单的情况，你的电脑只有一个CPU，所有的运算都必须由这个CPU来完成。

那么，我们不妨把这个CPU想象成一座大桥，桥上只有一根车道，所有车辆都必须从这根车道上通过。（很显然，这座桥只能单向通行。）

系统负荷为0，意味着大桥上一辆车也没有。

![img](uptime 负载.assets/bg2011073004.png)

系统负荷为0.5，意味着大桥一半的路段有车。

![img](uptime 负载.assets/bg2011073005.png)

系统负荷为1.0，意味着大桥的所有路段都有车，也就是说大桥已经"满"了。但是必须注意的是，直到此时大桥还是能顺畅通行的。

![img](uptime 负载.assets/bg2011073006.png)

系统负荷为1.7，意味着车辆太多了，大桥已经被占满了（100%），后面等着上桥的车辆为桥面车辆的70%。以此类推，系统负荷2.0，意味着等待上桥的车辆与桥面的车辆一样多；系统负荷3.0，意味着等待上桥的车辆是桥面车辆的2倍。总之，当系统负荷大于1，后面的车辆就必须等待了；系统负荷越大，过桥就必须等得越久。

![img](uptime 负载.assets/bg2011073007.png)

**CPU的系统负荷，基本上等同于上面的类比。大桥的通行能力，就是CPU的最大工作量；**

**桥梁上的车辆，就是一个个等待CPU处理的进程（process）。**

**如果CPU每分钟最多处理100个进程，那么系统负荷0.2，意味着CPU在这1分钟里只处理20个进程；系统负荷1.0，意味着CPU在这1分钟里正好处理100个进程；系统负荷1.7，意味着除了CPU正在处理的100个进程以外，还有70个进程正排队等着CPU处理。**

**为了电脑顺畅运行，系统负荷最好不要超过1.0，这样就没有进程需要等待了，所有进程都能第一时间得到处理。很显然，1.0是一个关键值，超过这个值，系统就不在最佳状态了，你要动手干预了。**



###**系统负荷的经验法则**

1.0是系统负荷的理想值吗？

不一定，系统管理员往往会留一点余地，当这个值达到0.7，就应当引起注意了。经验法则是这样的：

当系统负荷持续大于0.7，你必须开始调查了，问题出在哪里，防止情况恶化。

当系统负荷持续大于1.0，你必须动手寻找解决办法，把这个值降下来。

当系统负荷达到5.0，就表明你的系统有很严重的问题，长时间没有响应，或者接近死机了。你不应该让系统达到这个值。



###**最佳观察时长**



**最后一个问题，"load average"一共返回三个平均值----1分钟系统负荷、5分钟系统负荷，15分钟系统负荷，----应该参考哪个值？**

**如果只有1分钟的系统负荷大于1.0，其他两个时间段都小于1.0，这表明只是暂时现象，问题不大。**

**如果15分钟内，平均系统负荷大于1.0（调整CPU核心数之后），表明问题持续存在，不是暂时现象。所以，你应该主要观察"15分钟系统负荷"，将它作为电脑正常运行的指标。**







##当iowait较高时使用pidstat -d 2 





https://blog.csdn.net/ligupeng7929/article/details/89888768





`````shell
pidstat [ 选项 ] [ <时间间隔> ] [ <次数> ]
`````



pidstat 示例
pidstat 的用法：

pidstat [ 选项 ] [ <时间间隔> ] [ <次数> ]
如下图：

 

常用的参数：

-u：默认的参数，显示各个进程的cpu使用统计
-r：显示各个进程的内存使用统计
-d：显示各个进程的IO使用情况
-p：指定进程号
-w：显示每个进程的上下文切换情况
-t：显示选择任务的线程的统计信息外的额外信息
-T { TASK | CHILD | ALL }
这个选项指定了pidstat监控的。TASK表示报告独立的task，CHILD关键字表示报告进程下所有线程统计信息。ALL表示报告独立的task和task下面的所有线程。
注意：task和子线程的全局的统计信息和pidstat选项无关。这些统计信息不会对应到当前的统计间隔，这些统计信息只有在子线程kill或者完成的时候才会被收集。
-V：版本号
-h：在一行上显示了所有活动，这样其他程序可以容易解析。
-I：在SMP环境，表示任务的CPU使用率/内核数量
-l：显示命令名和所有参数

`````shell
pidstat
pidstat -u -p ALL
`````



