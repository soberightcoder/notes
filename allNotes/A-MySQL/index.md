# index 索引



## 是否使用索引  ----- 受很多因素影响；

* 扫描行数  rows ；
* 是否回表
* 是否排序，是否需要排序；
* 是否需要文件排序，是否使用临时表； 





##  索引下推



mysql5.6 之后的特性：

就是回表：先进行数据的过滤再回表还是，直接回表；







## 添加索引的原则



https://blog.csdn.net/wpc2018/article/details/123115384





1、字段的数值有唯一性限制

2、频繁作为where查询条件的字段

3、经常GROUP BY 和 ORDER BY 的列

4、UPDATE、DELETE时 的 WHERE 条件中的列

5、DISTINCT 去重字段需要创建索引

6、多表连接时创建索引













##2、适合创建索引的情况



**1、字段的数值有唯一性限制**  这边可以加一个 唯一性索引；来保证他的唯一性；

索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中,如果哪个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引。这样可以更快速地通过该索引来确定某条记录。

例如，学生表中学号是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。



**2、频繁作为where查询条件的字段**



某个字段在SELECT语句的WHERE条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。

当不建索引时的查询时间：查询到10038条数据，时间花费 310ms

select course_id,class_id,name,create_time,student_id from student_info where course_id = 10085;



在course_id字段上创建索引：

create index idx_cid on student_info(course_id);
1


再次执行相同查询：查询到10038条数据，时间花费 30ms，提升非常明显



**3、经常GROUP BY 和 ORDER BY 的列**



索引就是让数据按照某种顺序进行存储或检索，因此当我们使用GROUP BY对数据进行分组查询，或者使用ORDER BY对数据进行排序的时候，就需要对分组或者排序的字段进行索引。如果待排序的列有多个，那么可以在这些列上建立组合索引。

**如果查询中既使用了 GROUP BY 又使用了 ORDER BY，可以建立联合索引，其中 GROUP BY使用的字段放前面， ORDER BY使用的字段放后面。**？？？？？？？？？？ todo  我咋感觉这里有点不对呢？



**4、UPDATE、DELETE时 的 WHERE 条件中的列**

**UPDATE、DELETE时 的 WHERE 条件中的列需要创建索引。**

对数据按照某个条件进行查询后再进行UPDATE或 DELETE的操作，如果对WHERE字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据WHERE条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。

**5、DISTINCT 去重字段需要创建索引**

有时候我们需要对某个字段进行去重，使用DISTINCT，那么对这个去重的字段创建索引，也会提升查询效率。

**6、多表连接时创建索引**

1、对WHERE 条件的列创建索引，因为WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有WHERE条件过滤是非常可怕的。

<font color=red>2、对用于连接的字段创建索引，并且该字段在多张表中类型必须一致。比如course_id在student_info表和course表中都为int(11)类型，而不能一个为int另一个为varchar类型。</font>



**7、对使用列的数据类型范围小的创建索引**   字段的数据类型比较小适合创建索引，占用内存比较小；



数据类型越小，在查询时进行的比较操作越快

数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

当表的主键的数据类型范围小时，更适合加索引，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/0。



**8、使用字符串前缀创建索引·**

````mysql
#局限性前缀索引无法使用order by 和 group by,也无法使用前缀索引做覆盖扫描
````



**假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。**  

**前缀索引无法使用order by 和 group by,也无法使用前缀索引做覆盖扫描**



这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。

**9、区分度高（散列性高）的列适合作为索引**

列的基数指的是某一列中不重复数据的个数，比方说某个列包含值2，5，8，2，5，8，2，5，8，虽然有9条记录，但该列的基数却是3。也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。

可以使用下面公式计算区分度，越接近1越好，一般超过33%就算是比较高效的索引了。

 select count(distinct a)/count(*) from t1
1
拓展:联合索引把区分度高(散列性高)的列放在前面。

<font color=red>**10、使用最频繁的列放到联合索引的左侧**</font>

最佳左前缀原则

**11、在多个字段都要创建索引的情况下，联合索引优于单列索引**







##3、限制索引的数量
索引并不是越多越好，要根据查询有针对性的创建。虽然MySQL单个普通表上最多能建65个索引（64个二级索引 + 1个主键索引），**但还是建议单张表索引数量不要超过6个，原因：**



**索引并不是越多越好，索引可以提高查询的效率，但会降低写数据的效率。有时不恰当的索引还会降低查询的效率。**

**每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。**



**索引会影响INSERT、DELETE、UPDATE等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。**





**优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。**





##不适合创建索引的情况

1、**在where，GROUP BY 或 ORDER BY中使用不到字段，不要设置索引**

2**、数据量小的表最好不要使用索引**；

3、**禁止给表中的每一列都建立单独的索引**；

4**、有大量重复的列上不要建索引**；  区分度比较小的不要创建索引；

5、**不要对经常更新的表和频繁更新的字段创建索引**  //频繁更新的字段不要创建索引；

6、不建议用无序值作为索引

例如身份证、UUID、MD5、HASH、无序厂字符串等。
7、删除    不再使用或者很少使用的索引

8、**不要定义冗余或重复的索引**

重复：primary key(id)，index(id)，unique index(id)

冗余：index(a,b,c)，index(a,b)，index(a)，

**// 删除一些重复和冗余的索引；**

**重复的和冗余的索引会降低查询效率，因为MySQL查询优化器会不知道该使用哪个索引。**



---



## 前缀索引



https://blog.csdn.net/weixin_40980639/article/details/105364266



一、怎么创建前缀索引
当我们索引的字段是很长的字符串时，可以用到前缀索引
表结构

````mysql
CREATE TABLE `tb_goods_spu` (
  `id` bigint(20) NOT NULL COMMENT '主键',
  `goods_name` varchar(128) NOT NULL COMMENT '商品名称',
  PRIMARY KEY (`id`)
  ）
    
## mysql demo.student
mysql> alter table student add index index_name(name(4))
 -> ;
Query OK, 0 rows affected (0.31 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> show create table student;
+---------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table   | Create Table
                    |
+---------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| student | CREATE TABLE `student` (
  `name` char(10) NOT NULL DEFAULT '',
  `course` char(10) NOT NULL DEFAULT '',
  `score` int(11) NOT NULL DEFAULT '0',
  KEY `course_index` (`course`),
  KEY `index_name` (`name`(4))
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
+---------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
    
#查询效果；
mysql> select * from student where name=name;
+-------+--------+-------+
| name  | course | score |
+-------+--------+-------+
| name1 | amth   |    81 |
| name2 | amth   |    81 |
| name3 | amth   |    80 |
| name4 | yuwen  |    76 |
| name4 | yuwen  |    71 |
| name4 | yuwen  |    76 |
+-------+--------+-------+
6 rows in set (0.00 sec)
    
````

创建前缀索引结构

alter table tb_goods_spu add key(goods_name(5));
1
我们创建了一个长度为5的前缀索引，如何确定前缀缩影的长度呢？

二、确定前缀索引的长度
我们可以先查出最常见的商品名称数据

select count(*) as count,goods_name from tb_goods_spu 
GROUP BY goods_name ORDER BY count desc limit 10;
1
2
结果：

我们发现前面的出现的次数都是几次和十几次

我们先从2个前缀字母开始

select count(*) as count,left(goods_name,2) as pre from tb_goods_spu 
GROUP BY pre ORDER BY count desc limit 10;

结果：

前缀的个数比原来的次数多了，因为唯一前缀比唯一商品名称要少得多。我们可以增加前缀长度

select count(*) as count,left(goods_name,7) as pre from tb_goods_spu 
GROUP BY pre ORDER BY count desc limit 10;

结果：


我们发现到7就接近了，可以建长度为7的。

三、局限

**前缀索引无法使用order by 和 group by,也无法使用前缀索引做覆盖扫描**

这里的数据太少，不太明显。但是只要更接近原字段的选择性就行。







##group by 和 order by 一起使用时，会先使用group by 分组，并取出分组后的第一条数据，所以后面的order by 排序时根据取出来的第一条数据来排序的，但是第一条数据不一定是分组里面的最大数据。

解决方案：

**可以先排序，再分组，再排序：使用子查询。**

```mysql
SELECT
  r.id,
  r.uid,
  r.age ,
  r.datatime
FROM (SELECT
    id,
    uid,
    age ,
    datatime
  FROM student
  ORDER BY age DESC) r
GROUP BY r.uid
ORDER BY r.age DESC;

#用排序来保证数据的第一条是最大的；  group by 和 order by  一起使用的案例
# derived  派生表  from之后的就是派生表，注意需要 as r 给派生表取别名；
```

**注意：group by 比order by先执行，order by不会对group by 内部进行排序，如果group by后只有一条记录，那么order by 将无效。** 





##  不走索引的几种情况



* 数据类型不匹配  （join的联表数据类型要一致；）
* 字段使用了函数
* 使了不等于匹配方式  ！= not null is not null  not in 这样的；都不走索引
* or必须两个都有索引才会走索引
* 不满足最做匹配原则
  * 字符串的模糊匹配
  * 联合索引的最左前缀原则
* 优化器的选择问题：
  * 不仅仅受扫描的行数影响；
  * 是否需要排序；  
  * 回表； 这个很重要；  不要忘记  优化器有可能选择全表扫描 不需要回表；ALL；
  * limit的个数；

