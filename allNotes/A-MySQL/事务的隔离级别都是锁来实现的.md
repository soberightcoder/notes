# 事务的隔离级别都是通过锁来实现

>RU，不加锁，一直都是可以并发，执行的；
>
>**RU：读未提交；就是不加任何的锁；**
>
>**下面RC and RR，只要是快照读的情况下就可以并发执行；快照读和写是可以并发的；**
>
>**RC：读已提交，会在每条SQL前加MVCC乐观锁，并且update delect for update/share in mode lock；一般不使用next-key lock;**
>
>**RR: 可重复读，会在事务的第一条SQL下加MVCC乐观锁，并且会使用next-key lock ，来保证数据的一致性和隔离性；**
>
>**串行化： 直接加行锁，在读数据的时候会加share in mode!，来保证，只有一个事务在执行；**
>
>---
>
>**RC，在每条sql语句的时候会更新readview 也就是读视图；**
>
>---
>
>**锁是在事务提交之后释放的！！commit 之后释放锁！！**
>
>---
>
>mysql5.7 来查看事务的隔离级别：
>
>show varaibles like "transaction_isolation";

---



**Developer/Programmer (vscode-openai)** Date: 12/3/2023, 8:27:07 PM

是的，事务的隔离性是通过锁来实现的。在数据库中，事务的隔离级别定义了事务之间的可见性和并发控制的级别。不同的隔离级别使用不同的锁机制来确保事务之间的数据隔离。

以下是常见的事务隔离级别和它们使用的锁机制：

1. **读未提交（Read Uncommitted）：最低级别的隔离级别，事务可以读取其他事务未提交的数据。在这个级别下，没有使用锁来保护数据。**
2. **读已提交（Read Committed）：事务只能读取已经提交的数据。在这个级别下，使用短暂的共享锁（Shared Lock）来保护读取的数据，以防止其他事务修改。mvcc乐观锁和行锁 间隙锁来实现，但是mvcc乐观锁加的时机和RR是不一样的；对于每个SQL语句来说，在RC隔离级别下都会创建一个新的一致性视图，以确保事务在执行过程中能够看到一致性的数据状态。** 
3. **可重复读（Repeatable Read）：事务在整个事务期间看到一致的数据快照，即使其他事务对数据进行了修改。在这个级别下，使用共享锁（Shared Lock）来保护读取的数据，并使用行级锁（Row Lock）来防止其他事务修改已读取的数据。读快照是不加锁的？？？是吗？**
4. 串行化（Serializable）：最高级别的隔离级别，事务按顺序执行，彼此之间完全隔离。在这个级别下，使用行级锁（Row Lock）来保护读取和修改的数据，以确保事务之间的完全隔离。

**锁机制在事务隔离中起着重要的作用，它们确保了事务之间的数据隔离和并发控制。通过适当选择和配置隔离级别，可以平衡数据的一致性和并发性能。**

请注意，不同的数据库管理系统可能会有不同的实现方式和锁机制。上述描述适用于一般情况，具体的实现细节可能因数据库系统而异。



---



**是的，只有在MySQL中使用RC（Read Committed）和RR（Repeatable Read）这两种事务隔离级别时，才会使用间隙锁（Gap Locks）。**

在RC隔离级别下，当事务执行范围查询时，MySQL会在查询过程中对索引范围内的间隙（即两个索引键之间的区间）进行加锁，以防止其他事务在这个范围内插入新的数据，从而避免不可重复读（Non-Repeatable Read）的问题。

在RR隔离级别下，MySQL会在事务执行范围查询时对索引范围内的间隙进行加锁，以避免其他事务在这个范围内插入新的数据，从而避免幻读（Phantom Read）的问题。

因此，只有在这两种隔离级别下，MySQL才会使用间隙锁来确保数据的一致性和隔离性。

---

## RC and  RR 快照读  是不是不加锁的？？？

> **肯定呀，不加锁；用mvcc 乐观锁，来解决快照读不加锁的问题！！！**

在MySQL中，读已提交（Read Committed）和可重复读（Repeatable Read）隔离级别下的快照读是不加锁的。

在读已提交隔离级别下，快照读（也称为非锁定读）可以读取已经提交的数据，而不会对数据进行加锁。这意味着其他事务可以同时修改被读取的数据，可能导致读取到不一致的数据。

**在可重复读隔离级别下，快照读（也称为一致性非锁定读）会创建一个事务开始时的一致性视图，并在整个事务期间使用该视图来读取数据。这意味着其他事务对数据的修改不会影响当前事务的读取操作。快照读不会对数据进行加锁，因此允许其他事务并发地修改数据。**

需要注意的是，虽然快照读不会对数据进行加锁，但在可重复读隔离级别下，快照读会使用一种称为行级锁（Row Lock）的机制来防止其他事务修改已读取的数据。这种行级锁是隐式的，由MySQL引擎自动管理，不需要用户显式地操作。

总结起来，在读已提交和可重复读隔离级别下的快照读是不加锁的，允许其他事务并发地修改数据。这提供了更高的并发性能，但也可能导致读取到不一致的数据。



---

## 各个隔离级别的加锁问题！！

**一，读未提交(****Read Uncommitted****)**

**这种事务隔离级别下，select语句不加锁。**

*画外音：官方的说法是*

*SELECT statements are performed in a nonlocking fashion.*



此时，可能读取到不一致的数据，即“读脏”。这是并发最高，一致性最差的隔离级别。



**二，串行化(****Serializable****)**

**这种事务的隔离级别下，所有select语句都会被隐式的转化为select ... in share mode.**



这可能导致，如果有未提交的事务正在修改某些行，所有读取这些行的select都会被阻塞住。

*画外音：官方的说法是*

*To force a plain SELECT to block if other transactions have modified the selected rows.*



这是一致性最好的，但并发性最差的隔离级别。



在互联网大数据量，高并发量的场景下，几乎**不会使用**上述两种隔离级别。



**三，可重复读(****Repeated Read, RR****)**

这是InnoDB默认的隔离级别，在RR下：

（1）**普通的select使用快照读(snapshot read)，这是一种不加锁的一致性读(Consistent Nonlocking Read)，底层使用MVCC来实现，具体的原理在中有详细的描述；**



（3）加锁的select(select ... in share mode / select ... for update), update, delete等语句，它们的锁，依赖于它们是否在唯一索引(unique index)上使用了唯一的查询条件(unique search condition)，或者范围查询条件(range-type search condition)：

  **- 在唯一索引上使用唯一的查询条件**，会使用记录锁(record lock)，而不会封锁记录之间的间隔，即不会使用间隙锁(gap lock)与临键锁(next-key lock)

  **- 范围查询条件**，会使用间隙锁与临键锁，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻影行记录，尽量避免不可重复的读

*画外音：这一段有点绕，多读几遍。*



关于**记录锁，间隙锁，临键锁**的更多说明，详见《[InnoDB的七种锁](http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651967369&idx=1&sn=d639abf6772a72c25cc2537749258163&chksm=bd2d7a558a5af3436e0a435a3e7cd9f72f67c1269370be936a82dc0af483f47aefa48bd58d69&scene=21#wechat_redirect)》。



**四，读提交(****Read Committed, RC****)**

这是互联网最常用的隔离级别，在RC下：



（1）普通读是快照读；



（2）加锁的select, update, delete等语句，除了在**外键约束检查**(foreign-key constraint checking)以及**重复键检查**(duplicate-key checking)时会封锁区间，**其他时刻都只使用记录锁**；

此时，其他事务的插入依然可以执行，就可能导致，读取到幻影记录。

**
**

**总结**

（1）并发事务之间相互干扰，可能导致事务出现读脏，不可重复度，幻读等问题；

（2）InnoDB实现了SQL92标准中的四种隔离级别；

**- 读未提交**：select不加锁，可能出现读脏；

**- 读提交(RC)**：普通select快照读，锁select /update /delete 会使用记录锁，可能出现不可重复读；

**- 可重复读(RR)**：普通select快照读，锁select /update /delete 根据查询条件情况，会选择记录锁，或者间隙锁/临键锁，以防止读取到幻影记录；

**- 串行化**：select隐式转化为select ... in share mode，会被update与delete互斥；

（3）**InnoDB默认的隔离级别是RR，用得最多的隔离级别是RC；**

