# 死锁检测

>死锁；
>
>innodb 才会有死锁；有事物；多加注意；
>
> 互斥性；
>
>线程阻塞不会放弃自己的资源；
>
>不能够去强抢别人的资源；
>
>形成资源依赖；
>
>

-----



## 死锁

----

MyIsam不支持事务。myisam的每次的读写都会隐性的加上读写锁，并未出现过锁死的情况。读锁是共享的，而写锁是独占的，意味一个session在写的时候，另一个session必须等待；没执行一条sql语句就会释放锁，所以不存在死锁的问题；

innodb 是支持事物，并且是在事物结束后释放锁；



**就是两个或者2个以上的线程去争夺资源，造成了资源的相互依赖，若无外力，就会一直持续下去，就会产生了死锁；**

---

## 死锁产生的4个必要条件？

产生死锁的必要条件：

1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4. 环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。

----



innodb_lock_wait_timeout 默认是50s  50s 解开 肯定是不行的

innodb_deadlock_wait = on 开启死锁等待



---



**尽量让数据表中的数据检索都通过索引来完成，避免无效索引导致行锁升级为表锁。**  **// 升级为表锁不会有死锁的问题了；**//todo





**合理设计索引，尽量缩小锁的范围。**尽量减少查询条件的范围，尽量避免间隙锁或缩小间隙锁的范围。



**尽量控制事务的大小，减少一次事务锁定的资源数量，缩短锁定资源的时间。**      很多死锁  都是长事务导致的；所以尽量去控制事务的大小把；



**如果一条SQL语句涉及事务加锁操作，则尽量将其放在整个事务的最后执行。****执行时间最长的sql语句放在最后面；**



**尽可能使用低级别的事务隔离机制。**



---

1. 以固定的顺序访问表和行。比如对第2节两个job批量更新的情形，简单方法是对id列表先排序，后执行，这样就避免了交叉等待锁的情形；又比如对于3.1节的情形，将两个事务的sql顺序调整为一致，也能避免死锁。
2. 大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。
3. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。
4. 降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。
5. 为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。

----

## 死锁防止；



* 减少锁的范围： 主要是设计的索引，减少锁的锁定范围； 这边主要是设计合理的索引；  锁的范围要小；

* 控制事物的大小，很多死锁都是长事物导致的；  锁的时间要小；

* 执行时间最长的sql放在最后面；    //////执行完直接解锁；

* 合并成多次操作；一段时间内的频繁操作可以合并成一次操作；

  











