

# KMP

>高效的字符串匹配算法；**快速的从一个主串中找到一个匹配串；时间复杂度是n；**
>
>kmp算法主串的指针并不会回溯，匹配串是部分回溯，一般并不会回溯到开始；
>
>但是如果使用普通的算法，不匹配的时候需要重新从头开始匹配之后，那么需要的时间复杂度是n*m; 
>
>普通算法，比较低的原因是匹配串和主串度会存在指针回溯的问题；
>
>![image-20221207224929897](KMP.assets/image-20221207224929897.png)

利用匹配，next前缀数组来做一个匹配；



KMP算法是由3个外国人最先发现的，并以他们的名字首字母命名，该算法是一个高效的串匹配算法，该算法比较难理解，但是时间复杂度大大降低。

该算法主要优化了朴素算法里把模式串里的字符看做单独随机字符的做法。具体如下：

每一次比较之后，找到不同的元素
然后通过next数组找到模式串下一次匹配的字符下标
难点是如何构造next数组？



---

## 基础逻辑

主串：aabaabaaf       ；

匹配串：aabaaf         ；

next：最长相等（公共）前后缀； [0,1,0,1,2,0] ； 匹配串的最长公共前后缀；

前后缀表的求解： 

前缀：包含首字母，不包含尾字母的子串；

后缀：包含尾字母，不包含首字母的子串；



前缀 ：a   aa  aab  aaba  aabaa  前缀表的 **最长相等前后缀**；

后缀 ：f    af   aaf   baaf  abaaf 



最长相同前后缀：

a  0;

aa   a  a  1；

aab   a  aa  |  b ba  0;

aaba a aa aab   | a ab aba 1;

aabaa a aa aav aaba   | a  aa baa abaa 2；

aabaaf  a aa aab aaba aabaa  | f af aaf baaf abaaf  0;



---



## KMP code

一次KMP算法的完整执行包括构造 pnext 表 和 实际匹配，设模式串和目标串长度分别为 m 和 n， KMP算法的时间复杂度是 O(m+n)。多数情况下 m<<n,可以认为这个算法的时间复杂度是 O(n)。

步骤：

先要生成next数组，然后再进行匹配；

`````php
##求next数组；

`````

