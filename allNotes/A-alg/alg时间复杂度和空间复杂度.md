# alg时间复杂度和空间复杂度

>仅仅就是一个预估；减少没必要时间的浪费；不需要完全把整个项目写出来；

### 时间复杂度

---



T(n) = O(f(n))

<font color=red>代码的执行时间  随着 数据规模 (n)增长的变化趋势；</font>

**或者去计算执行次数最多的那段代码执行了多少次；**

总的时间复杂度等于量级最大的那段时间复杂度；

常见的时间复杂度 **O(1) < O(logn)<O(n)<O(nlogn)<O(n\^2)<O(2\^n)<n!**



**表现形式：**

O(1) 常数时间复杂度，只要不存在循环和递归，即使是千万条语句也是常数时间复杂度；

O(logn) 对数时间复杂度，二分查找，二叉索引树；//归并 快排；

O(n) 正常遍历；

O(n^2) 双重循环遍历；

O(2^n) 递归操作； **斐波那契数列；**



### 空间复杂度    注意这里是额外的空间复杂度；去除本身的代码也会占用的内存空间；

---



<font color=red>存储空间随着数据的规模增长的变化趋势；</font>

除了本身存储空间还需要的额外的存储空间；

**表现形式：**

O(1) 原地操作；**一般要求创建的空间和数据的规模没什么关系；**  不需要额外的内存空间；

O(n) 开辟线性辅助空间（数组）；



## 最好情况，最坏情况，平均情况时间复杂度（或者叫期望值）；

---

**大部分情况下不需要区分最好最坏和平均；但是：**



<font color=red>**当同一块代码在不同的情况下，时间复杂度有量级的差距，我们就需要使用****，**那么就需要 平均时间复杂度；****</font>



**最好情况时间复杂度，最坏情况时间复杂度，平均情况时间复杂度；**

eg：

`````php
# 找到位置；
function main($arr,$val){
    $len = count($arr);
    $pos = -1;
    for($i=0;$i<$len;$i++){
        if($arr[$i] == $val){
            $pos = $i;
            break;
        }
	}
    return $pos;
}
//同一块代码在不同的情况下，时间复杂度的量级存在差距；在数组内和数组外的量级是不同的，所以需要平均时间复杂度；
//平均时间复杂度是O(n)

#期望时间复杂度的计算：
# 1/n+1 + 1*2/n+1 + ....+1*n/n+1 + 1*n/n+1 (1+n)*n+2n/2(n+1) === n 也就是n的时间复杂度；
`````





### 均摊时间复杂度；（把时间复杂度高的操作耗时，均摊到时间复杂度比较低的操作上）

<font color=red>**当大部分情况下时间复杂度都很低，只有个别情况下时间复杂度很高**</font>，而且这些操作之间存在前后连贯的关系，这个时候，我们就可以将这一组操作放在一块儿分析，**看是否能将较高时间复杂度那次操作的耗时**，**平摊到其他那些时间复杂度比较低的操作上。**

**而且，在能够应用均摊时间复杂度分析的场合，<font color=red>一般均摊时间复杂度就等于最好情况时间复杂度。</font>**
