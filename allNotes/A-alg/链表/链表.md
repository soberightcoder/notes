# 链表  LIST

---



 ## 模板



`````php
# 链表遍历
function listTravel($head) {
    //非递归
    while($head) {
        echo $head->val;
        $head = $head->next;
    }
    // 递归
    if ($head == null) return null;
    echo $head->val;
    // 前序位置--递--入栈；
    listTravel($head->next);
    // 后序位置--归--出栈；
}

`````



---



## 案例



##<font color=red>前序是递的过程，后序是归的过程，后序可以拿到子函数的处理结果；可以一层层的递归出来；可以处理子函数的结果；</font>



``````php
# 链表的翻转
/**
 * list的翻转
 * 链表的翻转 其实就是翻转指针；
 *
 * 数组的翻转 ，其实就是交换；
 *
 * 双指针
 * 这里要画图好好看一下；
 */

function listReverseB2p($head){
     //
    $cur = $head;
    $pre = null;// 虚拟节点
    while (!is_null($cur)) {
        //这里需要暂存 一下下一个节点 不然会被下一行代码截断
        $tmp = $cur->next;

        $cur->next = $pre;
        $pre = $cur;
        $cur = $tmp;
    }
    return $pre;
}
//var_dump(listReverseB2p($head));die;
/**
 * 递归 翻转 链表
 * 一个个翻转的过程都一个个和大模块类似的小模块，解决这些大模块和小模块的方法都是一样的，所以才可以用递归；还有结束条件；
 */

function listReversedigui($cur,$pre) {
    if ($cur == null) return $pre;// 注意之类一定要返回 $pre
    $tmp = $cur->next;
    $cur->next = $pre;
    // 这里要一层一层的传递出来，
    $pre = listReversedigui($tmp,$cur);
    //后序遍历 才可以拿到子树的结果；后序遍历可以拿到子函数的结果；
    return $pre;
}

var_dump(listReversedigui($head,null));die;


``````





## 循环链表

循环链表的判断条件  注意这两个tiao'jian

* 满链表
* 空链表 

````php
````

