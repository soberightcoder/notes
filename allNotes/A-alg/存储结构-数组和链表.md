#alg - 存储结构(数组 链表；)

> 存储方式分为 顺序存储(数组) 和链式存储(链表)；
> 其他数据结构的基础； 只有这两种存储方式；

### 数组（连续内存）

特性：

1. **支持随机访问**；根据key去查询，O(1)的时间复杂度；
2. 插入和删除的时间复杂度是O(n);
3. 被缓存，加速访问（连续内存）；缓存的命中率变高，来加速访问；


---



### 链表（单向链表，双向链表，循环链表）（不需要连续的内存，内存的利用率比较高；）

>双向链表，主要是为了方便删除**（删除需要上一个结点；）（插入结点，需要上一个结点**），再一个是方便范围查询，大于并且小于多少值的树；
>
>**指针本身就是一个地址（其实跟内存大小有关；）：64位占用8个字节，32位的占用4个字节；**   跟地址总线一样； 就是寻址总线；
>
>**在不同操作系统中指针大小结论**
>**（1）在32[位操作](https://so.csdn.net/so/search?q=位操作&spm=1001.2101.3001.7020)系统下，指针是占4个字节空间大小，不管是什么数据类型**
>**（2）在64位操作系统下，指针是占8个字节空间大小，不管是什么数据类型**

**alg: 还是要去多做 没有什么技巧可言；****链表 next prev 指针；**

单向链表特性：

1. 插入和删除O(1);必须要有
2. 遍历O(n)
3. 不支持随机访问；
4. **比数组占用更多的存储空间；**

---

**链表（单链表）的结点的概念：**

**指针next的概念，指针存储了这个变量的内存地址；**

p->next 下一个结点；

p->val 代表p结点的值；

**head 代表头指针 指向第一个结点** **找到第一个结点而已**，**\$head 就是代表的是头结点**；head  === p    头结点head等价于p；

head->next =null 代表这个链表只有一个结点；  head ->p->null

head=null； 空链表 head->null;  就是一个空链表；

p->next = null ; 代表p就是最后一个结点；





**链表（单链表）的插入和删除：**

````php
#查询上一个结点
#$p的上一个结点  时间复杂度是O(n)
while($head){
   if($head->next == $p){
       return $head;
   }
    $head = $head->next;
}
````



**删除：** **p->next = p->next->next;** 
注意这里是删除p后的结点，并不是删除p结点，如果需要删除p结点，那么需要遍历找到p的上一个结点；那么就是O(n)的时间复杂度，但是可以使用双链表，直接用p->prev->next = p->next;

还有一种特殊链表的删除  head->p->null



if(head->next == null){

head = null;

}

head == null；代表这是一个空链表；

````php
if ($head == null) return $head;
if($head->next == null) return $head == null;
return $p->next = $p->next->next;
````



**插入：**

head -> a->b->null   **在ab 之间插入 c  a 结点是知道的（前结点已知） 在a后插入c a 结点是已知的；**



**c->next= a->next;**

**a->next=c;**

 

```php
// 空链表；
f($head == null){
# next 默认是null；
$head = $new_node

}
```

**注意：**

**链表的边界条件：**

````php
# 空链表
$head == null
#一个结点的链表；
$head->next == null 
#两个结点的链表；
$head->next->next = null
//在处理头结点和尾结点的时候是否能正常工作；
//注意 while 中的 迭代 需要这么写；
#链表节点的移动；快慢指针；
$fast = $fast->next->next;
$head = $head->next;  

````

**注意php的对象的比较问题：**

````php
// 如果仅仅是属性值的比较；
$obj1 == $obj2;  // 就是属性值相同；
//如果属性中存在自身的引用对象那么需要用 === 来比较；不然会报错；
Nesting level too deep - recursive dependency    嵌套级别太深 - 递归依赖？ 递归栈空间用光了；
    
//// 
    
//所以对象的比较比较严格 一般都是用  === !==  不然会报错； 复杂数据结构其实都会存在自身引用的一个问题，怎么去比较？？？
    
//如果两个对象共享一个属性作为其值，PHP将在这些属性对象之间进行相同的==比较。现在，只要这些属性对象是递归的(例如，自引用对象)，比较也会向下递归，直到达到最大嵌套级别’
    
#而我的那段代码 循环链表正是 自引用对象 , 所以出现这个问题, 解决方法上面图片也提到了, 就是自引用对象相互比较的时候要是使用 === 代替 == 
    
$arr0 = [1,2,3,4];
$arr1  = [1,2,3,&$arr1];
$arr2 = [1,2,3,&$arr2];
if($arr1 === $arr2){
   echo "相等";
}else{
    echo "不相等";
}
#数组也会存在这个问题；
$arr0 = [1,2,3,4];
$arr1  = ['1',2,3,&$arr0];
$arr2 = [1,2,3,&$arr0];
// 数组 这里不能比较；循环嵌套引用；
if($arr1 === $arr2){
   echo "相等";
}else{
    echo "不相等";
}
if($arr1 == $arr2){
    echo "相等";
}
#不相等 和 相等；
#所以数组  不要用引用自身，容易形成循环嵌套引用，数组之间的比较 全等 仅仅是数据和数据类型是一致的; 数组一般就是传的是副本，对副本的操作基本不会对本身有影响；
     
#对象也是 但是会存在嵌套循环的处理，更加严格把；  因为本身对象 就是一个引用；  除了 clone 是一个副本，传引用；


### 注意 无论式 == === 都会牵扯到 深度遍历  复式数据结构引用的问题；
##  ==  只比较 数值； 不比较数据类型；   === 全部比较；

Fatal error: Nesting level too deep - recursive dependency? 
    //  都会牵扯到
$arr0 = [1,2,3,4];
$arr1  = [1,2,3,&$arr1];
$arr2 = [1,2,3,&$arr2];
if($arr1 == $arr2){
    echo "相等";
}else{
    echo "不相等";
}

//  nesting level too deep  嵌套级别太深了；

````



**for  和 while的区别？**



1. 其实低层是一样的，两者可以相互转换；

   while 只有条件 和循环体

   for(;condition;) {} 也是只有循环体 两者都是一样的，for仅仅是多了初始 循环体和 迭代值而已；
   
   
   
   **for(1;2;3)  1 初始值。 2 终止条件  3  循环增量；**

​	**如果while的循环增量  可以在最后 两者中间完全可以替换；**





### 指针

指针（内存大小和数据类型无关，和系统操作位数有关），在32位操作系统里面，一个char * ，int * ，long *，所占的内存大小都是32bit，也就是4个byte。



一、程序运行平台

       不同的平台上对不同数据类型分配的字节数是不同的。
       个人对平台的理解是CPU+OS+Compiler，是因为： 
       1、64位机器也可以装32位系统（x64装XP）； 
       2、32位机器上可以有16/32位的编译器（XP上有tc是16位的，其他常见的是32位的）； 
       3、即使是32位的编译器也可以弄出64位的integer来（int64）。 
       以上这些是基于常见的wintel平台，加上我们可能很少机会接触的其它平台（其它的CPU和OS），所以个人认为所谓平台的概念是三者的组合。 
       虽然三者的长度可以不一样，但显然相互配合（即长度相等，32位的CPU+32位的OS+32位的Compiler）发挥的能量最大。 
       理论上来讲 我觉得数据类型的字节数应该是由CPU决定的，但是实际上主要由编译器决定(占多少位由编译器在编译期间说了算)。

二、常用数据类型对应字节数
       可用如sizeof（char),sizeof(char*)等得出
       32位编译器：

```markdown
    32位编辑器；
  char ：1个字节
   											char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
   short int : 2个字节
   int： 4个字节
   unsigned int : 4个字节
   float: 4个字节
   double: 8个字节
   											long: 4个字节
   long long: 8个字节
   										unsigned long: 4个字节

    64位编译器：

   char ：1个字节
                                                   char*(即指针变量): 8个字节
   short int : 2个字节
   int： 4个字节
   unsigned int : 4个字节
   float: 4个字节
   double: 8个字节
   											long: 8个字节
   long long: 8个字节
   										unsigned long: 8个字节
   										
   										long关键字表示一种长整型数据，是编程语言中的一种基本数据类型，为long int 的缩写，默认为有符号长整型，含4个字节，取值范围为：-2^31 ~ (2^31 -1)。”
   										
   										
   										
   										long，一般代表机器字长，也就是一次能处理的数据最大宽度，一般和寄存器的位宽是等价的。在32位的处理器中，寄存器的位宽一般是32bit，即4个字节，所以，long的长度是4个字节在64位的处理器中，寄存器的位宽一般是64bit，即8个字节，所以，long的长度是8个字节


###long 字长  数据总线的位数  代表的是一次能处理的数据的最大宽度；

```
