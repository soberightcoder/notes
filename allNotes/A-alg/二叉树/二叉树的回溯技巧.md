# 回溯  -- 递归

><font color=red>**回溯的过程放在递归的参数里面；**</font>
>
><font color=red>**注意空指针；对象里面的空指针；** </font>
>
><font color=red>**在php中就是下一个left right 或者next == null；**</font>

---

## code

````php
## leetcode-112 路径总和
## 

/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     public $val = null;
 *     public $left = null;
 *     public $right = null;
 *     function __construct($val = 0, $left = null, $right = null) {
 *         $this->val = $val;
 *         $this->left = $left;
 *         $this->right = $right;
 *     }
 * }
 */
class Solution {

    /**
     * @param TreeNode $root
     * @param Integer $targetSum
     * @return Boolean
     */
    function hasPathSum($root, $targetSum) {
        // 从0开始还是从$root->val 开始？
        if ($root == null) return false;
        return $this->traverse($root,$targetSum,$root->val);
    }
    // 想用sum 求和把
    function traverse($root,$targetSum,$sum) {
        // 叶子结点的定义 左右结点都是null；
        // 这里仅仅是子节点 的判断，注意空指针；
        if ($root->left == null && $root->right == null) {
            if ($sum == $targetSum) {
                return true;
            } else {
                return false;
            }
        }
        // 回溯；sum 要做回溯的；需要靠递归的参数来进行回溯
        // $sum += $root->val;  // 如果直接写  我们需要做回溯 我们可以直接传入参数；这个函数定义域内 sum的值发生变化;所以这里肯定是有问题的；
        // 存在就直接返回；return；
        if ($root->left) {
            if ($this->traverse($root->left,$targetSum,$sum + $root->left->val)) return true;
        }
   
        if ($root->right) {
                   if ($this->traverse($root->right,$targetSum,$sum + $root->right->val)) return true;
        }
        //不存在  这个路劲；
        return false;
    }
}

````



````php
## 二叉树的所有路径；
##leetcode-- 257 

/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     public $val = null;
 *     public $left = null;
 *     public $right = null;
 *     function __construct($val = 0, $left = null, $right = null) {
 *         $this->val = $val;
 *         $this->left = $left;
 *         $this->right = $right;
 *     }
 * }
 */
class Solution {

    /**
     * @param TreeNode $root
     * @return String[]
     */
    public $res = [];  //

    function binaryTreePaths($root) {
        $str = ''.$root->val;
        $this->help($root,$str);
        return $this->res;
    }

    protected function help($root,$str) {
          //end recursion condition
        if ($root->left == null && $root->right == null) {
            // $str .= '->'.$root->val;
            $this->res[] = $str;  //怎么回溯？？？
            return;
        }
        //存在问题 当有两
        // 回溯
        if ($root->left) {
            $this->help($root->left,$str."->".$root->left->val);
        }

        if ($root->right) {
            $this->help($root->right,$str."->".$root->right->val);
        }
    }
}
````





`````php
# 返回二叉树路径和的所有路径；
#leetcode -- 34  二叉树中和为某一值的路径的所有路径；

/**
 * 剑指 Offer 34. 二叉树中和为某一值的路径
 *路径和的问题
 */
class Solution12 {

    /**
     * @param TreeNode $root
     * @param Integer $target
     * @return Integer[][]
     */
    public $res = [];

    function pathSum($root, $target) {
        if ($root == null) return [];
        $sum = $root->val;  // 如果只有一个结点 会导致叶子结点还没有插入进去  如果没有整个设置；// 极限情况的话 直接看一个结点就行了

        $path = [$root->val];
        $this->help($root,$target,$sum,$path);
        return $this->res;
    }

    // 利用内部参数的可变性来做一个回溯；回溯--回溯--回溯；
    //必须要传递参数 才能进行回溯，因为要进行回退嘛；
    protected function help($root,$target,$sum,$path) {
        //叶子结点
        if ($root->left == null && $root->right == null) {
            if ($sum == $target) {  // 0 null 问题
                $this->res[] = $path;
            }
            return;
        }


        if ($root->left) {
            array_push($path,$root->left->val);
            $this->help($root->left,$target,$sum + $root->left->val,$path);
            array_pop($path);
        }

        if ($root->right) {
            array_push($path,$root->right->val);
            $this->help($root->right,$target,$sum + $root->right->val,$path);
            array_pop($path);
        }

    }

}
`````







## 回溯 \$i++ \++$i \$i + 1 这三个大坑



````php
/**
 * 77. 组合
 *  n个数 k的组合
 * // 第一种求解方法 可以用暴力求解 就是需要用 k次for循环，k越大那么时间复杂度越高； 不建议使用；
 * // 第二种就是回溯 算法，其实就是一个二叉树 可以去画图看一下 但是注意去重问题；
 * ***** 去重 剪枝问题
 */
class Solution {

    /**
     * @param Integer $n
     * @param Integer $k
     * @return Integer[][]
     *
     */
    public $res = [];
    public $tmp = [];
    /**
     * n [1,n] // 1--n  n个整数
     */
    function combine($n, $k) {
        $this->traversel($n,$k,1);
        return $this->res;
    }

    /**
     * @param $n
     * @param $k
     * @param $startIndex //来做去重处理 搜索的起始位置
     *
     */

    function traversel($n,$k,$startIndex) {
        //end //end c 结束条件
        if (count($this->tmp) == $k) {
            $this->res[] = $this->tmp;
            return;
        }
        //单层递归逻辑
        for ($i = $startIndex; $i <= $n; $i++) {//本层 i++ 本层数据的循环
            array_push($this->tmp, $i);
//            $i = $i + 1;
            //$this->traversel($n, $k, ++$i);  // 下一层的；// 下一层的startIndex+1//下一层数据的循环
             //$i--;
            $this->traversel($n, $k, $i + 1);  // 下一层的；// 下一层的startIndex+1//下一层数据的循环
           
            array_pop($this->tmp);//回溯
        }
    }
}
$obj = new Solution();
var_dump($obj->combine(4, 2));die;

######## 注意########################
## $i++ 肯定不行的，不会去加1
## ++$i === $i = $i + 1 传 $i 参数  所以 需要回溯  $i--;
## $i + 1 直接自动完成了回溯  $i 的值 在递归中并没有发生变化，所以并不需要进行回溯，或者自动进行了隐藏的回溯；



// $i++   和  ++$i $i + 1 在回溯算法中的大坑；
````





## 回溯的剪枝处理；

```php
##组合的剪枝处理

 /**
         *   剪枝操作
         */
class Solution
{
    public $tmp = [];
    public $res = [];
    
    function combine($n, $k) {
            $this->help($n, $k, 1);
            return $this->res;
        }

   //  单层递归；
        function help($n, $k, $startIndex) {
            $len = count($this->tmp);
            //end c
            if ($len == $k) {
                $this->res[] = $this->tmp;
                return;
            }
            // 单层递归  // 剪枝操作，$i <= $n - ($k - $len) + 1; 因为包含 <= 所以需要往后面移动一位
            // 纯粹是因为包含 $i 吗？// 所以要加1？？？//todo 为什么加1 后面看一下把；
            // eg 数组的遍历
            // for end cond  $i <= $len - 1; $i < $len;
            for ($i = $startIndex; $i <= $n - ($k - $len) + 1; $i++) {
                array_push($this->tmp, $i);
                $this->help($n, $k, $i + 1);
                array_pop($this->tmp);
            }
        }
}
        
```



