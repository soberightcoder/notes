#  构建二叉树

>根据前序遍历 中序遍历 或者后序遍历来构建二叉树；
>
>一般解题思路就是

----

## 构建二叉树基础

````php
## 已知 前序遍历 和 中序遍历来创建一个二叉树
#3 关键是去找根结点和左右结点；
##### 找三个结点  根结点和左右结点；
##  寻找后序 和 前序的  左前序和右后序；
##怎么通过 左子树 或者右子树的长度 来左关联；
````

### 前序 和中序 来重建二叉树

````php
/**
 * 二叉树的重建
 * 知道前序和 中序 然后去重建二叉树
 * 剑指 Offer 07. 重建二叉树
 */
class Solution10 {

    /**
     * @param Integer[] $preorder
     * @param Integer[] $inorder
     * @return TreeNode
     */

    // 前序遍历// 结点值并不重复；
    function buildTree($preorder, $inorder) {
        if (empty($preorder)) return null;
        $rootval = $preorder[0];  // root 根结点
        $root = new TreeNode($rootval);
        //只有一个结点
        if (count($preorder) == 1) return $root;  // 这里的结点的左孩子或者有孩子 回去接住他；
        // inorder index  == roo tval 的索引
        $n = count($inorder);
        for ($index = 0; $index < $n; $index++) {
            if ($inorder[$index] == $rootval) {
                break;
            }
        }
        //切中序 分为两部分  左中序  和  右中序；
        $inleft = array_slice($inorder,0,$index);
        $inright = array_slice($inorder,$index + 1);

        // 切前序 分为 左前序  和 右前序 两部分；
        $len = count($inright);
        //array_slilce 有问题；
        // $len == 0 的时候会出问题；
        //  0的情况会有问题； 卧槽；妈的
        if ($len == 0) {
            $preright = array();
            $preleft = array_slice($preorder,1);
        } else {
            $preright = array_slice($preorder,(-$len));
            $preleft = array_slice($preorder,1,(-$len));
        }


        //递归； 递归左右结点；
        //递归； 递归左右结点；
        $root->left = $this->buildTree($preleft,$inleft);

        $root->right = $this->buildTree($preright,$inright);

        return $root;
    }
}
````

### 用中序 和后序来重建二叉树；

`````php
## 雷同 看上面的代码 array_slice  有空；


// 对上面的优化 对长度做一个匹配
class Solution101 {

    /**
     * @param Integer[] $preorder
     * @param Integer[] $inorder
     * @return TreeNode
     */

    // 前序遍历// 结点值并不重复；
    function buildTree($preorder, $inorder) {
        if (empty($preorder)) return null;
        $rootval = $preorder[0];  // root 根结点
        $root = new TreeNode($rootval);
        //只有一个结点
        if (count($preorder) == 1) return $root;  // 这里的结点的左孩子或者有孩子 回去接住他；
        // inorder index  == roo tval 的索引
        $n = count($inorder);
        for ($index = 0; $index < $n; $index++) {
            if ($inorder[$index] == $rootval) {
                break;
            }
        }
        //切中序 分为两部分  左中序  和  右中序；
        $inleft = array_slice($inorder,0,$index); // 用长度来左匹配；
        $inright = array_slice($inorder,$index + 1); //

        
        // 注意来做匹配；
        // 切前序 分为 左前序  和 右前序 两部分；
        $lenleft = count($inleft);
        $lenright = count($inright);
        //array_slilce 有问题；
        // $len == 0 的时候会出问题；
        //  0的情况会有问题； 卧槽；妈的

        $preleft = array_slice($preorder,1,$lenleft);
        $preright = array_slice($preorder,1 + $lenleft);


        //递归； 递归左右结点；
        //递归； 递归左右结点；
        $root->left = $this->buildTree($preleft,$inleft);

        $root->right = $this->buildTree($preright,$inright);

        return $root;
    }
}
$preorder101 = [1,2];
$inorder101 = [2,1];

$obj101 = new Solution101();
var_dump($obj101->buildTree($preorder101,$inorder101));die;
`````







---



## 路径总和  

> 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。
>
> 很像一个深度优先遍历；
>
> 这边确实用到了回溯；  参数应该在递归的内部，当回退的时候参数会发生也会发生回退；
>
> 因为前序只能接收，参数传递的内容，而后序可以接收子树的参数和内容；

``````php
## 路径总和 需要用 回溯； 回溯； 回溯；很重要的一个思想；
##起始就是回溯的技巧
# 去看一下回溯技巧篇； 整个是一个回溯；
``````





---

##  序列化 和反序列化的问题

> 树的序列化 和反序列化的问题；

```php
##JSON 的运用非常广泛，比如我们经常将变成语言中的结构体序列化成 JSON 字符串，存入缓存或者通过网络发送给远端服务，消费者接受 JSON 字符串然后进行反序列化，就可以得到原始数据了。这就是「序列化」和「反序列化」的目的，以某种固定格式组织字符串，使得数据可以独立于编程语言。

## json把复杂树结构转换成 字符串 来做一个数据的传输；tcp面向字节的，然后传送给其他服务器，反序列化得到数据原始数据；

##那么假设现在有一棵用 Java 实现的二叉树，我想把它序列化字符串，然后用 C++ 读取这棵并还原这棵二叉树的结构，怎么办？这就需要对二叉树进行「序列化」和「反序列化」了。
```

``````php
##PS：一般语境下，单单前序遍历结果是不能还原二叉树结构的，因为缺少空指针的信息，至少要得到前、中、后序遍历中的两种才能还原二叉树。但是这里的 node 列表包含空指针的信息，所以只使用 node 列表就可以还原二叉树。

##  
``````

`````php
## 树的前序 序列化 和 反序列化
class Codec1
{

    const SEP = ",";
    const NULL = "#";

    public $res = [];

    function __construct() {

    }

    /**
     * @param TreeNode $root
     * @return String
     * 前序 转换成字符串json  序列化
     */

    function serialize($root) {
        // if ($root == null) return []; // 整体为null；
        $this->help1($root);

        return implode(self::SEP, $this->res);
    }

    function help1($root) {
        if ($root == null) {
            array_push($this->res, self::NULL);
            return;
        }

        array_push($this->res, $root->val);

        $this->help1($root->left);
        $this->help1($root->right);
    }

    /**
     * @param String $data
     * @return TreeNode
     * 前序的反序列化
     */
    function deserialize($data) {
        $data = explode(self::SEP, $data);//arr
//        var_dump($data);die;
        return $this->help($data);
    }

    function help(&$data) {

        //endx
        if (empty($data)) return null;
        //
        $rootval = array_shift($data);
        if ($rootval == self::NULL) {
            return null;
        }

        $root = new TreeNode($rootval);

        $root->left = $this->help($data);
        $root->right =
            $this->help($data);

        return $root;
    }
}
`````





---

## 公共祖先

`````php
##最近公共祖先的问题
## leetcode = 236 二叉树的最近公共二叉树；


## leetcode -- 235 二叉树的最近公共er'cha

`````

