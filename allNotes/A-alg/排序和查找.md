# 排序和查找

>几种排序的方法： 
>
>冒泡 插入 选择  O(n^2)  基于比较；
>
>快排，归并 O(logn)  基于比较；
>
>桶，计数，基数 O(n)  不是基于比较；
>
>



### **排序算法执行效率的衡量标准？**时间复杂度

* 最好情况，最坏情况，平均情况时间复杂度

​		第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。

​		第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道		排序算法在不同数据下的性能表现。

* 时间复杂度的系数，常数和低阶；
* 比较次数和交换（移动）次数；

### 空间复杂度 也就是内存的消耗；

原地排序，空间复杂度是O(1)的排序算法；

### 排序算法的稳定性；

如果待排序的序列中**存在值相等的元素**，经过排序之后，**相等元素之间原有的先后顺序不变**。

**相同元素排序之后的先后顺序不变；**



稳定性的一个案例：

很多数据结构和算法课程，在讲排序的时候，都是用整数来举例，但在真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个 key 来排序。

比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？

最先想到的方法是：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂

。借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。为什么呢？

**稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。**第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序



## 冒泡 插入 和选择 比较适合小数据量的排序；



### 冒泡排序

**相邻的比较；**

**每一次冒泡比较n-1次就会排序好一个元素，那么只需要n次冒泡就会完成排序；**



````php
/**
 * @param $arr
 * @return mixed
 * 冒泡排序
 *
 */
function bubbleSort($arr){
    $len = count($arr);
    if($len <= 1) return $arr;
    for($i = 0;$i < $len;$i++){
        // 没有交换 那么就是有序的；
        $flag = false;
        //$len -1 代表 长度是len的数据只需要$len - 1 次比较就可以了；因为下面会有$arr[$j+1]  所以数据是$arr[$j+1]
        for($j = 0;$j<$len - 1 - $i;$j++){
            if($arr[$j+1] < $arr[$j]){
               $mid = $arr[$j+1];
               $arr[$j+1] = $arr[$j];
               $arr[$j] = $mid;
               $flag = true;
            }
        }
        //  有序 直接退出循环
        if(!$flag) break;
    }
    return $arr;
}
$arr = [1,2,3,6,5,4];
var_dump(bubbleSort($arr));die;
````



特性：

* **原地排序**； 只存在比较和交换；所以是原地排序；
* **稳定排序**： **为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换**，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。
* 冒泡排序的**时间复杂度是O(n^2)**  最好情况(**包含已经是有序  需要判断是否交换；)**至少需要一次冒泡，所以是O(n),最差的情况是需要n次冒泡，O(n^2);

















### 插入排序







### 选择排序



**也是分为未排序区间和已经排序的区间；**

**但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。**



 





## 快速排序 和归并排序 比较适合大数据量的排序



### 快速排序





### 归并排序

如果要排序一个数组，我们先把数组从中间分成前后两部分，**然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。**



**归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。**

是的，分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突。



