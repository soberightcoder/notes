#递归的本质 === 栈;

>**递归的本质是一个栈结构；**
>
>**用栈可以实现的这个案例，那么肯定可以用递归来实现；**



###怎么去写递归  ?? 主要是找 n 和n-1 之间的关系 ，然后再找递归结束的条件；



### 反转链表

>分析时间复杂度和空间复杂度  
>
>两种方式的优缺点？
>
>递归：优点：代码简洁；缺点：当链表非常长的时候，会导致函数调用栈层级很深，从而导致了函数调用栈溢出的问题；时间复杂度很高；2^n;
>
>
>
>显示用栈： 基于循环实现的代码鲁棒性要更好一些；时间复杂度是O(n)

​	

https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/



`````php

`````











### 递归怎么去计算时间复杂度和空间复杂度；



递归树  需要去看一下；懒腰待看-22720











### 递归的一个简单例子 N!的累加；



````php
/**
 * 1!+2!+...+N!;
 * 求n！式递归
 * 递归 和非递归
 * 非递归  其实就是 循环，累加；
 */
/**
 * @param $n
 * 累加
 */
// 累加
// 递归 需要的时间复杂度是n^2  // 空间复杂度是O(n) 就是会有额外的空间是O(n)
function accumulate($n) {
    $i = 1;
    $sum = 0;
    //n次相加
    while ($i <= $n) {
        $num += factorialhRecursion($i);//$num += factorialhRecursion($i++);// 先赋值  然后 ++ 自增；
        $i++;
    }
    return $num;
}
// n!的递归计算；
// 空间的时间复杂度会更多；
function factorialhRecursion($n){
    if ($n == 1 | $n == 0) return 1;
    return factorialhRecursion($n - 1) * $n;
}

// n!  非递归的形式的时间复杂度是O(n)  空间复杂度也是O(1) 常数级别的；
function factorialNoRecursion($n){
    // 三个额外的变量
    $p1 = 1; // 第一位的；
    $i = 1; //循环几次；从1开始的，所以这里也要从1开始，如果是3只需要循环三次就行了；
    $num = 0;// sum

    // end condtion
    while ($i <= $n) {
        $p1 = $p1 * $i;
        $i++;
        $num += $p1;
    }

    return $num;
}
// res
//var_dump(accumulate(3));die; // 1 + 2 + 6 = 9;
echo "\n";
//echo factorialhRecursion(2);
echo factorialNoRecursion(5); // 120 + 24 + 6 + 2 +1 =
//echo factorialNoRecursion(1); // 1  // 注意边界条件；
````



