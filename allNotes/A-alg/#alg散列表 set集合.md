#alg 散列表 set集合

### 散列表

> 用的是数组支持按照下标随机访问数据的特性；
>
> 所以散列表其实就是数组的一种扩展；php的关联数组；
>
> hash(key) == index 索引；
>
> 工业级代码map和set的实现 key就是key 省略了，hash(key)计算的过程；

key = >hash(key)散列函数 => 散列值；

**时间复杂度是O(1);支持随机访问；知道key 去寻找散列值的时间复杂度是O(1);**

hash(key) 散列函数；

散列函数的设计条件：

散列函数计算得到的散列值是一个非负整数；

如果 key1 = key2，那 hash(key1) == hash(key2)；

如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。

**散列冲突 ：key1 ！= key2  但是hash(key1) == hash(key2),就会存在哈希冲突；**

**装在因子：**

**装载因子 = 填入表的元素个数/散列表的长度；**

装载因子越大，说明空间越少，冲突越多，散列表的性能会下降；



**注意 这里的key当于是(工业级)关联数组的key； 后面保存的数据可以是 1 ，表示这个数据存在， 或者是统计的出现的次数；**

解决散列冲突的方式： 链表的方法；当存在冲突的时候如何找到自己value，需要用key来做比较，当和key相等的时候就是你要找的那个value；



了解**哈希碰撞**攻击原理：如果使所有的数据经过散列函数都在一个槽里，那么时间复杂度就会从O(1)退化成O(n),这样就会因为查询消耗

大量的cpu和系统资源，导致系统无法响应其他的请求，来达到DOS的攻击的目的；



**散列表的设计，尽可能的随机并且均匀分布；**



**当装载因子过大的时候就需要进行动态扩容；**虽然扩容会存在数据的搬迁，所以时间复杂度是O(n),但是很久才搬迁一次，平常的时间复杂度都是O(1),所以他的**均摊时间复杂度是O(1);**

**两种解决冲突的优缺点：开放地址法（占用别人的空间；），链表（开启一个新的维度）；**

**当数据量下，装载因子比较小的时候一般会用开放地址法；**



**map  和set的区别：**

**工业级别的应用；**他只需要复杂 你给他key 它可以在O(1)的时间复杂度内 给你找到你需要的值就可以了；

map 关联数组，其实就是键值对；键是不重复的，但是值可以是重复的；



**set 就是值不能是重复的；**

set 索引数组，值不能是重复的，php（索引数组） set不能保证互异性，去重的问题，一般是用关联数组的key来去重，或者使用array_unique(),但是效率很低；

也是需要遍历  value值放在一个数组的key上；如果为1 

