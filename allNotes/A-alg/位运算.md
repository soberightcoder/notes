### 位运算

>& | ~ ^ >>  <<  与或非异或左移右移

php获取一个变量的数据类型

var_dump();

gettype();



**求一个数值的二进制数**

`````php
$num = 1;
//echo gettype($num);
function getBit($num){
   for($i = 63;$i >= 0;$i--){
       #  跟打印有关 先求 最高位；先移动 63次；相与；
       echo ($num & (1 << $i)) == 0 ? "0" : "1";
   }
}
echo PHP_INT_SIZE;    // 8 字节 按照操作系统来统计的；
getBit($num);
`````

----

### 与 & 进位结果



**a & b << 1 也就是进位结果；** 



---



### 反码和补码

**32位：**

* 无符号 unsigned 2^32 -1;

* 有符号 -2^31 -1 ~ 0 2^31-1  一半给负的一般给正的；**0被分在非负数里面；**

负数： 符号位是1；**符号位不变，后面的位数取反+1；就是补码**；-1的表示；

**四位测试：**

**-1 + 1   = 1111 + 0001 = 0000   符号位进位之后变为0； 溢出就是不要了；**

**1000  1111 0000 0111 就是 -8  -1 0 8** **补码的进位是要保留的；**？？？ 1000 取反就是 1111 +1 = -8 取反+1？？？？？？？？？？？？？？？？？？？？？？？？？？

**补码存在的意思？**

运算的时候一套逻辑就可以了

**整数和负数的算术运算时只需要一套逻辑运算就就可以了；** 如果没有补码的含义那么就是：1001 + 0001 肯定不能直接运算的；结果不正确，那么负数需要另外一套逻辑；



<font color=red>**计算机计算的时候都是补码，正数的补码是本身，负数的补码就是取反+1；结果也是补码，要得到负数实际的二进制数字，需要取反+1**</font>



**概念原理：**

4位二进制原码中没有-8的表示，就不能用平时口诀的方法把-8进行原码补码的转换了。

要理解4位二进制补码中的-8是1000这结论，只能回到补码的起点。
介绍预备知识：
**先理解：补码利用模和同余概念在运算时可使减法转换成减法。**
**例如：在12小时制中，以1点钟为起点，向后逆时针转2点到11点，但向前顺时针转10点也是可以到11点的。如此就把1点-2点＝11点转换成1点+10点＝11点。此处模为12，-2与10对12同余。**

再回到本题：   
补码是在计算意义上存在的，是为了以加法代替减法。

**4位有符号二进制中模为8：-8的同余数就是0，则-8的补码为-000即1000，其来源为x-8要转换成x+0的加法计算意义。**

这样也符合补码的计算。例如-1+-7＝-8＝
-001（原码）+-111（原码）＝1111（补码）+1001（补码）＝11000＝1000（补码）

---



### 左移和右移  









>\>\> 逻辑右移（无符号）    都是补0；
>
> 算术右移动（会包含有符号）    **如果是负数 那么左边要补1； 非负数那么左边要补0；**
>
>左移 右边补0；
>
>**php中只有   >>   算术移动运算；**



num << N  num \*(2^N)

num >> N  num/(2^N) 



````php
# 左移动和右移动
//getBit(-5);
//getBit(-5 >> 3);
//getBit(5);
//getBit(5 >> 3);
1111111111111111111111111111111111111111111111111111111111111011
1111111111111111111111111111111111111111111111111111111111111111
0000000000000000000000000000000000000000000000000000000000000101
0000000000000000000000000000000000000000000000000000000000000000
    
#取反数  1 取反+1
echo (~1+1); //符号的表达； -1  取反+1（符号位也变成了1）   也可以 直接-1  取反之后 

#系统最小 取反+1 是自身，因为没有对应的正数
$min = PHP_INT_MIN;
getBit($min);
getBit(~$min + 1);
1000000000000000000000000000000000000000000000000000000000000000
1000000000000000000000000000000000000000000000000000000000000000
0取反还是自己
0000   ——》 1111 + 1 =》 0000 溢出了；
````



**注意：**  

**左移 是要补0的所以移动到最后数值为0；**

**右移 如果是负数 那么回事0xFFFFFFFFF，如果是整数那么也会是0；**







---



### 异或   无进位相加；



**N^0 = N 任意数和0异或是本身**

**N^N = 0 任意数异或本身是0**

**异或满足交换律和结合律**

**a^b = b^a**

**(a\^b)\^c = a\^(b\^c)** 

**奇数个数异或是本身，偶数个数异或是0；**



---

### 位运算 实现 + - * /



````php
/**
 * 位运算来实现  加
 * 异或运算就是无进位相加的结果
 * 进位结果: $x & $y << 1;
 */

function addByBit($x,$y){
    // $y == 0 直接return；
    $num = $x;
   	// $y == 0的时候也就是没有进位 直接进位信息消失就是结果；
    while($y){
        //无进位相加信息
        $sum = $x ^ $y;
        // 进位信息；
        $y = ($x & $y) << 1;  
        $x = $sum;
    }
    return $sum;
}
echo addByBit(2,3);
//echo addByBit(2,-1);

/**
 * 位运算 减
 * 不能出现 减加  不能出出现+ - 
 */
echo addByBit(2,-3);
echo addByBit(2,(~3+1));
echo addByBit(2,addByBit(~3,1));
````



----

### N & (N-1)   会把N最右边的1变为0；

-9223372036854775808





```php
/**
 * 获取变量的bit位；
 * 求一个数值的二进制数
 */
$num = 1;
//echo gettype($num);
function getBit($num) {
    // php 需要转换为64位；1<<63 这里是符号位；不移动是0号位； 所以总共64位l
    for ($i = 63; $i >= 0; $i--) {
        echo ($num & (1 << $i)) == 0 ? "0" : "1";
    }
    echo "\n";
}

/**
 * 1 左移 63位会发生什么
 * 溢出 ，php long 第一位是符号位；
 */
$flag = 1;
echo 1 << 63;//-9223372036854775808/溢出了 第一位是符号位置；，所以这里最多可以移动62位；最大时是2^63-1
echo "\n";
echo PHP_INT_MIN;// 1<<63 == PHP_INT_MIN;-9223372036854775808

/**
 * @param $n
 * @return int
 * $n & ($n -1)  最右边的1变为0
 * php 中 负数会变成死循环；
 */
//echo PHP_INT_MIN & (PHP_INT_MIN - 1);
//echo (PHP_INT_MIN - 1) & PHP_INT_MIN;
//die;

function optimalCount1B(int $n) {
    $count = 0;
    while ($n) {
        // 不为0；能进来肯定不为0
        $count++;
        $n = ($n - 1) & $n;
    }
    return $count;
}

/**
 * @param $n
 * @return int
 * 直接移动 1 标志位 左移；
 * 
 */
function moreCount1B($n) {
    $count = 0;
    $flag = 1;//与1相与；
    while ($flag) {
        if ($n & $flag) $count++;
        // 超过 8字节之后 直接跳出；
        $flag = $flag << 1;
    }
    return $count;
}


```



#### 交换变量的原地操作

```php
/**
 * 交换变量操作
     */

$x = 10;
$y = 1;
//list($x,$y) = array($y,$x);;
//echo $x,$y;//1  10
$x = $x ^ $y;
$y = $x ^ $y;
$x = $x ^ $y;
echo $x,$y;//1  10
echo  pow(2,3);// 指数的表示方法  并不是2^3 这个是异或；
```



###  求一个int整数的最后一个1；拿到最后一个1

```php
#  异或的操作；
($int * ($int - 1))  ^ $int
```







