# 网络底层逻辑



---

###问题：

```shell
1. 请详细介绍下TCP的三次握手机制,为什么要三次握手?
1.1 为什么要有握手?
1.2 为什么是三次?￼
2. 简单介绍下HTTP协议中缓存的处理流程?  
2.1 缓存的应用流程是什么?
2.2 与缓存相关的HTTP头部有哪些?
3. 在地址栏键入URL后,网络世界发生么什么?
4. 使用HTTP长连接有哪些优点?
5. CLOSE_WAIT状态产生的原因?
6. 介绍下多播是怎样实现的?
7. 服务器的最大并发连接数是多少?
8. TCP和UDP协议该如何选择?
9. TLS/SSL协议是如何保障信息安全的?
10. HTTP2协议有哪些优点?
```

---

### 通信模式

注:什么是单工、半双工、全工通信？



信息只能单向传送为单工；

信息能双向传送但不能同时双向传送称为半双工；

信息能够同时双向传送则称为全双工。

http是单工（只能从客户端到服务端，不能从服务端到客户端）；

tcp全双工；



---

##请详细介绍下TCP的三次握手机制,为什么要三次握手?

* 为什么需要握手？
  * 安全可靠传输，我发一个消息，seq  ack；
  * 同步序列号，mss，同步滑动窗口；？？？
  
* 为什么需要三次握手？

  * 同步seq 就需要三次握手，相互把对面的seq发过来？？

  

  
  
  ---
  
  

### HTTP的缓存处理流程？

强制缓存 expire  cache-control  max-age ;

协商缓存   if-modified-since  if-none-match  tag   就是在向服务器协商一下； 如果没有更新返回 304 ；更新了 直接返回200；

强制缓存优先级会高于 协商缓存；

ctrl + f5 强制刷新；不走缓存；重新缓存； 

f5 走协商缓存，去服务器问一下有没有更新；

回车就是正常访问；



---



### 地址栏输入URL，网络世界发生了什么？

dns 解析 域名解析；DNS

http 肯定是http协议；

协议 ios 五层；网络分层；



---



### HTTP的长连接的优点

优点： 

* 减少握手的次数；减少tcp握手的次数；减少握手的次数；
* 减少慢启动影响；就是拥塞控制的拥塞控制；

缺点： 

* 队头阻塞；当一个http请求阻塞，会阻塞后面的http请求；

  ---

  

### CLOSE_WAIT 状态产生的原因

tcp 建立连接之后，就不在分谁是客户端，谁是服务器，都可以发送信息，并且可以结束FIN连接，我们可以分为被动端和主动端；

**处于CLOSE_WAIT只有一端可以发消息，另外一断不可以发消息；**

---



### 能介绍一下多播是怎么实现的吗？



---



### 服务器的最大并发连接数？keepalive  其实是tcp的长连接；

TCP 是四元组 是由 源地址 + 源端口  + 目的地址+目的端口组成；

这里面 只有源地址 和 源端口是可变的；

源地址= 2^32      源端口 = 2^16=65536

所以最大并发连接数 =  2\^32*2^16 = 2^48 

linux的端口范围是受限制的；

服务器也有可能不仅仅有一个网卡，有可能会有多个网卡；

但是资源有限，内存资源有限；所以肯定不可能会有这么多的连接数；

处理一个连接时间不要太长；不然其他的连接有可能会超时；

##### 怎么实现高并发？  无阻塞，事件驱动？epoll； 

###### linux高并发优化？



---



#### TCP和UDP协议该如何选择？

**一个报文最多1500字节，Maximum Transmission Unit，*MTU*   最大传输单元；又数据链路层来控制；**

* UDP
  * 一对多通信；
  * 效率高；header比较短；
  * 简单；
  * 实时性更好；可以 丢包；面向报文；
    * 无队头阻塞问题；
* TCP   不需要再在应用层实现这些特性就可以使用tcp；
  * 字符流协议，传递任意长度消息； 
  * 可靠；seq ack；
  * 流量控制；滑动窗口；
  * 拥塞控制；
  * tcp notcpush 就是为了防止 header头比实际的信息body多；

---



### TLS/SSL协议是怎样保障信息安全的？

* 对称加密算法； 对称加密比较快；非对称加密比较慢；效率比较低，消耗的cpu比较高；

* 密钥交换协议；

* PKI证书体系；

  

---



#### http2.0有那些优点？

因为连接越多，内存消耗越多，cpu消耗就会越多，切换连接；所以 使用一个连接



http1.1 的缺点：

*  header 太长了，尤其是cookie；每次请求都会发一次；
* 头阻塞；
* 服务端 不能主动推送；

最多6个连接；谷歌浏览器；



　HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。



http 2.0  



多路复用，解决了头阻塞的问题；

hpack 编码 对header进行了压缩；

服务端推送的问题；



### MTU  限制报文的长度； 这个长度是包含头部信息的；

**为什么要有MTU**
**以太网最初对报文长度没有限制，网络层最大可以接收65535个字节，但是以太网对于长报文无法可靠地传输，而且丢失后重传也会占用大量的网络资源，而将报文限制在一定的长度，以太网可以将报文大概率传输到目的地，于是就有了MTU**

IP分片
既然链路层的payload有MTU限制，就意味着网络层下发到链路层的数据不能超过MTU，如果超过了，就需要在网络层分片，切成<=MTU的IP数据包

网络层如果发现链路层的MTU小于IP包的大小（网络层可以调用函数获取链路层信息），也并不会立刻开始分片，还需要看IP包的是否允许分片位DF(Don’t Fragment)，如果允许分片，就会分成多个ID一样的IP包

主机的网络层可以分片，路由器的网络层也可以分片，也就是说路由器的网络接口也有MTU限制

就像木桶理论一样，木桶能装多少水取决于最短的那块，网络通信的路径上决定IP包大小的，取决于源主机、目的主机、路由器中MTU最小的那个

UDP传输
**对于UDP包，如果MTU = 1500，那么udp payload最大值是多少，才可以不用分片？**

**MTU(1500) = IPHeader(20) + UDPHeader(8) + Data**
**Data = 1500 -20 - 8 = 1472**

**如果UDP包的Data <= 1472个字节，UDP包(UDPHeader+Data)在网络层不用分片，直接封装上IPHeader发往链路层**



**如果UDP包的payload > 1472，那么UDP包(UDPHeader + Data)在网络层需要分片，如何分片？**

网络层并不会在每个分片里复制一次UDP头，它是把完整的UDP包切开，加上IP头发送出去，除了第一个分片有UDP头，后面的分片都不包含UDP头

目的主机的网络层接收到多个UDP分片包后，网络层必须重组才能交给上层，为什么？

因为多个分片包只有第一个是有UDP头的，它可以根据UDP头里的端口号通知相应的应用取走，但是后面的分片包由于没有UDP头，传输层无法把分片包交给正确的应用程序。所以UDP分片包必须在网络层重组成一个完整的UDP包，交给传输层处理

网络层根据什么重组呢？还记得上面说的，分片的时候会分成多个ID一样的IP包吗？

如果某些分片包没有被目的主机的网络层接收到，造成UDP包重组失败，接收方会丢弃整个数据包，这是UDP不可靠传输的一个表现。而TCP发生组包错误时，该包会被重传，保证可靠传输

对于UDP来说，一般选择576个字节通信







