

#  IO的异步和同步  和 平常的异步阻塞





平常说的异步阻塞仅仅是客户端和服务器的一个工作模式



同步异步指定是客户端；

同步：就是没拿到数据就一致在等待；或者是不断的轮询去请求，直到拿到结果；**人很多需要去等待；这就是同步；**

异步：拿不到数据先返回执行自己的程序，当有结果就回调通知你；**点餐码；异步**



阻塞非阻塞 值得是服务器；

阻塞： 处理请求的线程只处理 这一个请求还是处理多个请求；处理完一个请求再处理其他的请求；  一个服务员面向一个顾客； 

非阻塞： 一个请求线程可以处理多个请求；就是轮询的方式；`` 一个服务员面向多个顾客；







IO  讲的是用户是怎么拿到这个数据的问题：



先讲一下I/O模型：
首先，输入操作一般包含两个步骤：

**等待数据准备好（waiting for data to be ready）。对于一个套接口上的操作，这一步骤关系到数据从网络到达，并将其复制到内核的某个缓冲区。**

**将数据从内核缓冲区复制到进程缓冲区（copying the data from the kernel to the process）。**



在IO中 程序（也就是用户；）就是客户端；

网卡：就是服务端；



同步阻塞：用户去执行轮询去获取；但是只能一个请求一个请求的处理；

同步非阻塞： 也是去轮询获取，但是accept和read不是阻塞操作；一个进程可以处理多个请求；



异步；就是程序使用epoll；多路复用，异步io；



当每有一个tcp连接，都会创建一个socket；我们把socke添加给socket事件；





**单线程就可以处理大量的请求；epoll , 非阻塞；**

``````php

# 同步阻塞 
#就像是去餐馆去吃饭；
#我就是一个请求，当餐馆人太多了（阻塞了，没有进程来处理我这个请求；），我们就需要在餐馆外面去等待，你们就是一个同步的过程；
#我扫码，拿到了，侯餐码，我就可以去逛商场，什么有座位了app就会通知我去就餐；

# 阻塞  我进入到了餐馆，然后就会有进程（服务员）来处理我，一个进程只服务我一个顾客，那就是阻塞；我在离开餐馆之前只服务于我一个人；

# 非阻塞  一个服务员服务于多个顾客，那么就是非阻塞的；我在离开餐馆之前服务于读个顾客；就是非阻塞；

## 阻塞  一个进程处理完一个请求之前，不能处理其他的请求；php就是这样的； 就是一个进程阻塞，就会阻塞到其他的请求；
## 阻塞 一个进程必须处理完一个请求之后才可以去处理其他的进程；会阻塞到后面的请求；
## 非阻塞 就是一个进程可以同时处理多个请求；并不会阻塞到后面的请求； 现在服务员就是非阻塞的一个人可以服务于多个顾客；


	while (1) {
        no_block; // 
		accept();
        read();
    }

## 这也是php是多进程的原因；一下子可以同时处理多个请求；防止阻塞都后面的请求；

## 异步非阻塞 就可以一个进程处理多个请求； 这里是异步的 epoll  这是io来说的；
## 同步非阻塞，select epoll 同步的去轮询；  这里是io;
``````

