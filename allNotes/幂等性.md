# 幂等性

><font color=red>乐观锁和悲观锁并不能解决幂等性问题，只能解决并发冲突问题</font>
>
>1. 随机token；  创建订单的唯一方法；这个可以保证接口的幂等性；
>
>2. 状态机；
>
>3. 唯一索引；、
>
>4. select  + insert 比较适合一些并发量不大的场景，查看一下看一下满足 不满足情况；//  场景比较特殊，每一个只能抢购一次；所以可以先去查看一下；这个会有并发问题；+  乐观锁，应该可以解决这个问题；并发量比较大要去做并发冲突的问题；
>
>   
>
>5.  本地消息时间表；这个一般用在kafka，消费失败重复消费的问题；
>
>6.  我们项目使用的是 一秒的锁，request:uid:url; 一秒的锁，防止重复提交的问题；--- 来解决幂等性的问题；防重复提交；
>
>----
>
>出现的场景：
>
>* 重试，接口的重试，要来保证他的幂等性；
>* 网络问题，其实修改成功了，但是提示你失败了；
>* 消息队列，消费失败，然后消费的问题；
>
>
>
>----
>
>理解 重复请求；他的每次token 提交都是一样的；

----

**多次请求，结果保持一致；**

**无论请求多少次都能达到预期的结果；**



俗的说，用户在系统中有操作，不管重复多少次，都应该产生一样的效果或返回一样的结果的。

幂等性的概念

幂等（Idempotent）是一个数学与计算机学的概念，常s见于抽象代数中。

**f(n) = 1^n // 无论n等于多少，f(n)永远值等于1**

在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数或幂等方法是指可以使用相同参数重复执行，并能获得相同结果的函数 / 方法。这些函数 / 方法不会影响系统状态，因此不用担心重复执行会对系统造成改变。例如：

1. 前端重复提交选中的数据，后台也只会产生对应这个数据的一个反应结果。

2. 用户发起一笔付款请求，就应该只扣用户一次钱，即使遇到网络重发或系统 bug 重发请求，也应该之扣一次钱。

3. 发送验证短息也应该只发一次，同样的验证短信不应该发送多次。

4. 创建业务订单，一个业务请求只能创建一个业务订单，创建多个就会出大问题。

这些等等很多的业务逻辑都需要幂等的特性来支持。

简单来理解就是，幂等就是一个操作，这个操作不管执行多少次，产生的效果和返回的结果都是一样的。比如说有一个 getOne () 函数，无论执行这个函数多少次，它返回的都是 1，这时就可以说它是一个幂等函数。



**放重表** 了解一下；



幂等性的技术方案

1. **查询操作**

查询一次和查询多次，在数据不变的情况下，查询结果都是一样的，select 是天然的幂等操作。

2. 删除操作

删除操作也是幂等的，删除一次和删除多次都是把数据删除。

3. **建立唯一索引，防止新增脏数据**

   唯一索引；

**当表存在唯一索引，并发时新增重复记录就会报错，那么这时候就查询已存在的记录并返回即可。**

4.**Token 机制，防止页面重复提交** // token的问题；就相当于 token；

**页面数据只能够提交一次，但是由于出现重复点击或者网络重发或 Nginx 重发等情况导致数据被重复提交的情况下，可以采用 Token+Redis（Redis 是单线程的，处理需要排队）的解决方案。处理的流程是，在数据提交前要向服务器申请带有有效时间的 Token，然后 Token 放到 Redis 或 JVM 内存中，当数据正式提交到后台要校验 Token 并删除 Token。**

 注意要去更新 

点击提交的时候 去拿token随机字符串；接连订单提交给服务器，服务器和保存到redis的数据做一个对比，查看一下有没有整个字符串，当正式提交后要后台 校验，token并且删除；

过期的问题，那么再传给前端一个过期时间，如果过期了就直接重新请求；

前端请求成功的时候，会删除整个token；





存在一个页面多个提交的问题？  涉及 一个页面多个提交的问题；

5. 悲观锁

获取数据的时候加锁获取：

select * from table where id = 'xxx' for update;
要注意的是，id 字段一定要是主键或者唯一索引，否则会导致锁表。

悲观锁的使用一般伴随事务一起使用，数据锁定事件可能会很长，要根据实际情况慎用。



6. **乐观锁**

**乐观锁只是在更新数据的那一刻锁表，其他时间不锁表，所以相对于悲观锁效率更高。**

**乐观锁的实现方式多种多样，可以通过 version 或者其他状态条件。**



7. **分布式锁**

**分布式锁对分布式的处理**  **解决一致性的问题；**

**还是拿插入数据的例子，如果是分布式系统，构建全局唯一索引比较困难，例如唯一性的字段无法确定。那么这时候就可以引入分布式锁，通过第三方的系统（Redis 或 Zookeeper），在业务系统插入数据或更新数据，获取分布式锁，然后做操作，之后再释放锁。这样其实是把多线程并发锁的思路引入了多个系统，也就是分布式系统中的解决思路。**

**要注意的是，某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志（用户 ID + 后缀等）获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁（分布式锁需要第三方系统提供)）。**



**8.select+insert**’



**对于一些并发不高的后台系统，或者一些任务 Job，为了支持幂等，支持重复执行，简单的处理方法是先查询下一些关键数据，判断是否已经执行过，然后再进行业务处理就可以了。但是要注意的是核心高并发流程不要用这种方法，因为效率较低。**



9. **状态机幂等**

   

**在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机（状态变更图），就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候如果状态机已经处于下一个状态，却来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。**

**要注意的是，订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助。**

总结

幂等性应该是一个合格程序员的基因，在设计系统的时候一定要考虑进去，尤其是像支付宝、银行、互联网金融公司等涉及的都是钱的系统，既要高效，也要准确，所以不能出现多扣款、多打款等问题，不然这样会很难处理，用户体验也不会好。

————————————————



**状态机 了解一下；**







**一、幂等性概念**
在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数. 更复杂的操作幂等保证是利用唯一交易号(流水号)实现.

我的理解：幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的。

**二、幂等性场景**
1、查询操作：查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作；

2、删除操作：删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个) ；



3、唯一索引：防止新增脏数据。比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录。要点：唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）；

4、token机制：防止页面重复提交。

原理上通过session token来实现的(**也可以通过redis来实现**)。当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中，然后将Token发给客户端（一般通过构造hidden表单）。
下次客户端提交请求时，Token会随着表单一起提交到服务器端。

服务器端第一次验证相同过后，会将session中的Token值更新下，若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变了。

5、悲观锁
获取数据的时候加锁获取。select * from table_xxx where id='xxx' for update; 注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的；悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用；

6、乐观锁——乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。乐观锁的实现方式多种多样可以通过version或者其他状态条件：
\1. 通过版本号实现update table_xxx set name=#name#,version=version+1 where version=#version#如下图(来自网上)；
\2. 通过条件限制 update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# >= 0要求：quality-#subQuality# >= ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高；

7、分布式锁

如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)；

8、select + insert
并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。注意：核心高并发流程不要用这种方法；

9、状态机幂等
在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助



10、对外提供接口的api如何z

保证幂等
如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号；source+seq在数据库里面做唯一索引，防止多次付款(并发时，只能处理一个请求) 。
重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。



11 有的状态机也需要保证保证幂等性，如果他的业务逻辑是 state4 +1 where state = 1;   如果是update set state  = state4 +1 where id = 1 and state = state3  状态机；





**三、总结**
幂等与你是不是分布式高并发还有JavaEE都没有关系。关键是你的操作是不是幂等的。一个幂等的操作典型如：把编号为5的记录的A字段设置为0这种操作不管执行多少次都是幂等的。一个非幂等的操作典型如：把编号为5的记录的A字段增加1这种操作显然就不是幂等的。要做到幂等性，从接口设计上来说不设计任何非幂等的操作即可。譬如说需求是：当用户点击赞同时，将答案的赞同数量+1。改为：当用户点击赞同时，确保答案赞同表中存在一条记录，用户、答案。赞同数量由答案赞同表统计出来。总之幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行，互联网金融公司等涉及的都是钱的系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题，这样会很难处理，用户体验也不好。

