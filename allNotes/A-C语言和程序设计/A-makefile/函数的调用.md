# 函数的调用

>wildcard and patsubst

## 函数调用语法

makefile函数调用原型：

`````makefile
$(<function> <arguments>)
#或
${<function> <arguments>}
`````

函数的调用以`$`开头，用`{}`或者`()`将函数名以及参数包含起来，`<function>`为函数名，`<arguments>`为参数，两者之间以空格分隔，若存在多个`<arguments>`参数，使用`,`分开。例如：

````makefile
#subst函数作用是将字符串“maktfilt中”的't'替换为'e'，其中函数名为subst ，参数为t,e,maktfilt
$(subst t,e,maktfilt) 
````

## 01 wildcard

wildcard函数调用原型：

```makefile
$(wildcard <PATTERN..>)
```

wildcard函数是针对通配符在函数或变量定义中展开无效情况下使用的，用于获取匹配该模式下的所有文件列表，`<PATTERN...>`参数若有多个则用空格分隔。若没有找到指定的匹配模式则返回为空。
例如：

````makefile
#返回make工作下的所有.cpp以及.c文件
$(wildcard *.cpp *.c)
````



## 02 patsubst  (pattern replacement 可以用匹配模式，也就是模式匹配)

>模式匹配：就是可以使用通配符来进行匹配！！！
>
>pattern 匹配的，replacement 需要替换的，text 文本；

patsubst函数调用原型：

`````makefile
$(patsubst  <pattern>,<replacement>,<text>)
`````

patsubst函数返回被替换过后的字符串。patsubst函数判断<text>中字符串（若多个字符串以空格分隔）是否匹配<pattern>模式，若匹配则使用<replacement>替换<text>。<pattern>可以包括通配符%表示任意长度的字串。如果<replacement>中也包含%，则<replacement>中的这个%将是<pattern>中的那个%所代表的字符串。若字符串中含有%则可以用反斜杠\来转义，即\%来表示真实含义的%字符。

示例：

`````makefile
#把字符串“x.c.c bar.c”符合模式%.c的单词替换成%.o，返回“x.c.o bar.o”。
$(patsubst %.c,%.o,x.c.c bar.c)
`````



## 特例：

````makefile
DIR_SRC = ./src
## 
SRC_NONE =$(DIR_SRC)/*.c *.c
SRC_WILDCARD = $(wildcard $(DIR_SRC)/*.c *.c)

OBJ_NONE_NONE = $(patsubst %.c,%.o,$(DIR_SRC)/*.c *.c) 
OBJ_WILDCARD_NONE = $(patsubst %.c,%.o,$(wildcard $(DIR_SRC)/*.c *.c))

OBJ_NONE = $(patsubst %.c,%.o,$(SRC_NONE)) 
OBJ_WILDCARD = $(patsubst %.c,%.o,$(wildcard $(SRC_WILDCARD)))

all:
	@echo $(SRC_NONE)
	@echo $(SRC_WILDCARD)
	@echo $(OBJ_NONE_NONE)
	@echo $(OBJ_WILDCARD_NONE)
	@echo $(OBJ_NONE)
	@echo $(OBJ_WILDCARD)

````

output:

````makefile
$ make
./src/src_a.c ./src/src_b.c a.c b.c
./src/src_a.c ./src/src_b.c a.c b.c
./src/*.o *.o
./src/src_a.o ./src/src_b.o a.o b.o
./src/*.o *.o
./src/src_a.o ./src/src_b.o a.o b.o

````

<font color=red>**可以看出，由于通配符`*`在函数定义中展开无效，所以`OBJ_NONE`在使用`patsubst`函数后`echo`的输出为`./src/*.o *.o`。而在`OBJ_WILDCARD`中使用`wildcard`函数使得通配符正确展开，最后`echo`输出了正确结果。**</font>

