# 指针与字符数组

>**地址：变量的属性，变量的存储在内存中的位置！！！**
>
>**指针：就是保存地址的变量！！！**
>
>指针可以间接的修改某个变量！！
>
>指针可以改变指向！！



`````c
// 
int main() 
{
    // 初始化的两种手段 
    // 字符串 ，所以要加尾0
    //会自动加\0
    //sizeof(str) == 6;
    //strlen(str) == 5;
	char str[] = 'hello'; //报错了 必须是双引号呀 大哥；字符串 肯定是双引号呀；
    //printf("%s\n",str); puts(str);都是输出到\0结束，所以我们一定要防止越界的问题产生！！！
    //字符数组，当成字符来用，所以不需要加\0 很好理解！！！！
    // 不会加尾0；
    // strlen(str1) == 4;
    //sizeof(str1) == 4;
    
    char  str1[] = {'a','b','c','d'};
    
    // FALSE
    //str = "jsjjsjs"; // 肯定是错的，因为str属于一个地址；所以不能给她赋值；
    
    //可以通过
    strcpy(str,"abcd");//赋值；
    
    //这是一个字符串常量把！！！
    char* p = "hello";
    p = "word";
    
}






#include <stdio.h>
#include <string.h>
/**
 * 指针和字符数组
*/

int main() {

    //串常量 和 指针的关系;
    //
    char str[] = "hello";   
    // puts(str);
    strcpy(str,"word");//数组的起始地址；str
    puts(str);
    // printf("%s",str);
    // 常量；代表的是，hello的起始地址是p;
    //指针指向一个常量！！！
    char* p = "hello";
    printf("%s\n",p);//hello
    puts(p);//hello
    printf("%c\n",*(p+1));//e
    
    // strcpy(p,"word");//会报错段错误！！！ 串常量，不允许被覆盖！！！
    p = "word";//指向另外一个字符串的地址就好了！！1
    printf("%s\n",p);

    return 0;
}
`````





`````c
//常量和变量；
//不是变量就是常量！！！！！
// 变量；
int a = 1;
int *p = &a;
*p  = 3; // 间接修改;
a = 2;  //直接修改   //我可以去修改变量的值；

//现在
int *q = 2;  //q 保存的是常量的地址；
//不能直接修改；
// 不能间接修改，因为会保存到 常量区；
//那我们只能去改变指针的指向来达到修改的目的；
q = 3;
`````

````c
    /**
     * 变量和常量的认识！！！
     * 常量保存在常量区；
     * 没有变量名，肯定就是常量；
     * p->a->value 变量！！
     * p->value == 常量！！
    */

    int a = 1;
    int* p1 = &a;
    *p1 = 2;
    printf("%d\n",a);//2
    a = 3;
    printf("%d\n",a);//3

    int* q = 2;

    // *q = 5; //常量不能修改
    q = 4;
    //这是整型 没有 *(q+1)的问题，仅仅是一个整型，并不是数组的关系！！！知道首地址就行了；注意中间少了一个变量，所以不需要*p
	//当成一个特殊情况来看就好了！！！
    printf("%d\n",q);
````





---

# 辅助知识

>**很重要的一个概念！！！ 只有变量才能给他赋值！！！**

```c
 //变量才能赋值！！！ 左边至少是一个变量！！！ 

//左边必须是一个变量！ 如果昨天是一个地址；那么分明是有问题的！！！

//*p 地址指向的变量；所以可以赋值  *p = 12333;

// int* p  = "abc";
int * p = "abc"; === const int *p = "abc";  // 
//改变他只能去改变他的指向；
//
```

