

# 函数的声明和定义

>**函数由函数头和函数体组成；**
>
>**声明只由函数名来组成！！**
>
>**声明，告诉编译器函数一些信息，比如函数返回值，函数名，和参数类型！**
>
>声明和定义，不一致，编译的时候不会出错，但是会在连接的时候报错！！！
>
>**进行声明就是说，我要在这个文件使用这个函数了**；
>
>

```c
//函数在使用之前必须要在调用之前定义！！
//程序自上而下执行！！！
void func() {
    printf("func\n");
}
//要在使用之前声明！！！
void funcb();// 不声明，会存在未定义的函数的警告！！；

int main() {
    func();
    funcb();//要声明；不然找不到函数；
}

void funcb() {
    printf("funcb\n");
}
```





##  为什么进行声明？



编译器希望确保你没有拼写错误或将错误的参数数量传递给函数。所以，它坚持在使用之前首先看到一个函数(或任何其他类型，类)的声明。

这真的只是允许编译器更好地验证代码，并允许它整理松散的文件组织形式，以便它可以产生一个整洁的目标文件。如果没有提前声明，编译器就会产生一个对象文件，该对象文件必须包含有关函数的所有可能猜测的信息。链接器就必须包含聪明的逻辑来尝试并计算出你实际打算调用的函数，当函数可能存在于不同的对象文件中时，链接器与使用添加生成的对象文件相连接一个dll或exe。链接器可能会收到错误的函数。假设你想使用int add(int a，float b)，但是忘记声明它，然而链接器发现了一个已经存在的int add(int a，int b)，并认为是正确的，而使用它。你的代码将成功编译，但不会得出你想要的结果。

所以，为了保持代码的清晰，避免歧义等等，编译器坚持要在使用前声明所有内容。

该资料内容来源于stackoverflow的问答。

具体内容见链接：#/questions/4757565/what-are-forward-declarations-in-c



最后有关C这个问题的答案是：C语言的“隐式函数声明”惹的祸 ：

隐式函数声明

在C语言中，函数在调用前如果没有声明，那么编译器会自动按照一种隐式声明的规则，为调用函数的C代码产生汇编代码。

但gcc编译器在编译时能够自动在常用库头文件(内建函数)中查找与隐式声明同名的函数，如果发现其返回非int类型，则会按照内建函数的声明原型去生成调用代码。这样编译时会给出警告，提示隐式声明与内建函数不兼容。

如果隐式声明函数名称恰好在链接库中存在，且返回int类型与gcc的内建函数原型完全相同，那么gcc不会给出任何警告。但是如果在调用时参数数量不匹配，就可能在运行时出问题。

为了避免这种问题，在C语言的C99版本中，无论如何都会给出警告。也强烈建议程序员重视编译器给出的关于隐式声明的警告，及时通过包含必要的头文件来消除这种警告。当然只要我们正确的声明和定义就不会出现一些奇怪的问题。



## 函数的声明和定义

![ce177e133baa4706ba80ff793900777](./%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89.assets/ce177e133baa4706ba80ff793900777.png)
