# 	C语言的指针



**指针变量**  \* p；**代表 这个变量存储的是地址**



**C语言中的一切函数调用中，值传递都是“按值传递”的。如果要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成。（如对一个函数传入一个x一个y，交换两者的值，如果只是按值传递，那在函数内交换并不影响函数外的x和y，而指针则可以做到）**

**其实这里的指针 就是我们其他语言的引用；**  

只有值传递，所以要存在指针；php 也是只有值传递，



**这里其实就是引用； 指针；**



````c
// a b 指向同一个地址；引用；
int main(void){
    int a = 111;
	// 存储的是地址； 指针变量  int 用来标记 夺取多少个地址？？？一个地址一个字节，int就是4个字节，需要读取四个地址的内容；
	int *b = &a;

	printf("%p",*b);  
    // %s 输出字符串；
}
````





**\* p 代表的是寻址； p 是变量，保存的是地址；**



`````c
int main(void){
    int a = 1234;
    //只有指针变量才能保存地址；
    int *c;
    // c是变量来保存地址 
    c=&a;
    // 取变量的内容需要*c 寻址；
    prinf("%d %d",*c,a);
}
`````



**&取地址符**     获取变量的地址；

 





**函数的调用问题**   

````c
#include <stdio.h>
void func(int *c){
    *c=1000;
}

int main(void){
    int a = 1234;
    func(&a);
    printf("%d",a);
    return 0;
}
````



**测试**

````bash
root@b28137ec3b07:/datadisk/website/ctest# ./a.out

1234 1234 0x7ffecda2d2c4
    
cat >> ceshi1.c <<EOF 
#include <stdio.h>
int main(void){
int a = 1234;
//int *b = &a;
//printf("%p",*b);
printf("\n");
int *c;
c = &a;
printf("%d %d %p",*c,a,c);
printf("\n");
}
EOF
    
#  直接用gcc 编译就可以了 编译成机器语言；out 然后直接运行就行了；
root@b28137ec3b07:/datadisk/website/ctest# gcc ceshi1.c  -o ceshi1.out
root@b28137ec3b07:/datadisk/website/ctest# ls
a.out  ceshi.c  ceshi1.c  ceshi1.out
root@b28137ec3b07:/datadisk/website/ctest# ./ceshi1.out

1234 1234 0x7ffec5da8684
````





###**结构体**  和   指针合起来的用法；

struct zval{

​		value;  //值；

​		type;  // 数据类型

​		is_ref;  //  是否引用；

​		refcount;   // 计数

}

````c
#include<stdio.h>
#include<string.h>
typedef struct book  // 直接取别名；
{
    char title[100]; // 字符串的大小；
    char autor[100]; // 字符串的大小；
 }book;

typedef struct book book; //取别名

/*
struct book
{
	char title[100];
	char autor[100];
}books[10];
struct book books;  // 直接就是创建10个结构体；
*/
int main(void)
{
	//struct book books[10]; // 10个结构体； // 相当于一个二维数组； 创建了10个结构体；
    book books[10];
    book *b = &books[0]; // 这里是地址；

    strcpy(books[1].autor,"ceshi1");  //访问结构体 就是book[1].autor  用点.来进行访问；
    strcpy(books[1].title,"ceshi1");
    strcpy(books[0].autor,"ceshi0");
    strcpy(books[0].title,"ceshi0");
    
    printf("%s\n %s\n",b->title,(*b).title);  // 地址直接通过箭头来访问；
    
}
````





### 函数



````c

#include<stdio.h>
//需要声明	
int ceshi(int ,int); // int	 声明返回的数据类型；
//或者直接定义在前面
int ceshi1(int a)
{
    return a*2;
}
//返回的是一个指向整型的指针；
int* func()
{
	// 注意 他会在返回之前销毁掉；
    int arr[2] = {2,3}; 
    arr[1] = 1;
    return arr
}

int main(void)
{
    ceshi(1,3);
    ceshi1(1);
    int *p = func();
    printf("%d",p[1]);  // null  报错；
    return 0;
}

int ceshi(int a,int b)
{
    return a+b;
}
// 返回数组

````



### \#include 的问题

\#是预处理指令

include 是“包含”的意思

**include " XX" 或者 #include ,意思是将"XX"或者中的文件引用到本程式中来,**

"XX"或者中的文件通常是由系统提供的，其扩展名为 .h。

因此也称为头文件或首部文件。

C语言的头文件中包括了各种标准库函数的函数原型。

**\\#include < stdio.h >是包含 stdio.h 头文件的意思， .h是头文件的扩展名（header file），stdio.h就是standard input output.header，也就是“标准输入、输出"头文件,**

**这个文件的内容就是基本输入输出函数的声明，比如scanf()和printf()，**



**你的程序包含了stdio.h，就相当于声明了这些函数，这样你才能够在自己的程序中使用它们【 scanf() 或 print() 】。**

**所以，若要在程序中调用一个库函数，包含该函数原型的头文件就必须要有，一般是写在程序开头。**

**\#include <math.h> 是包含math头文件的意思， .h是头文件的扩展名（header file），这一句声明了本程序要用到标准库中的 math.h文件。math.h头文件中声明了常用的一些数学运算，比如乘方，开方运算等等。**

**每条#include语句只能包含一个头文件。如果有多个头文件，就得分别写多个#include语句，每行一条#include只语句，每条#include语句也只包含一个头文件。**



###指针数组和数据类型

int  

char 每个字符都是1个字节；ascII 当然这里需要看字符集；

***ASCII码对照表* ASCII, American Standard Code for Information Interchange** 

double

```c
#include<stdio.h>
//void === null   就是没有参数 void main();就代表没有返回值；
int func(int arr,int a)
{
    a=1000000;
    arr[2]=100;
    return arr;
}
int main(void){
    int a = 123;
    char b = 'b';    // charset 需要去查看一下 字符集；
    double c = 1.223;   // 8字节；
    int arr[5] = {1,2,4,5,5};    //int 数组元素的数据类型，arr 代表数组的首地址；5代表数组的长度；
    							// 任意一个元素的地址都可以通过  arr+4*(index)来计算地址；
    arr[2] = 3;              //赋值；
    printf("%d",arr[1],*(arr+1));// *(arr+1) 会指向下一个元素的地址； === *(arr+1)== a[1]
    
    //指针模拟一个数组；
    int * const arr2 = (int *)malloc(sizeof(int)*5);  //const 代表arr2 地址无法改变；了解就可以了。目前；
    //
    //free  malloc  申请之后释放掉
   	// free(arr2);
    // 很重要的部分；
    func(arr,a);
    printf("%d",arr[1],a);  //arr 发生了改变，而
}
```





```c
#include <stdio.h>

int func(int arr[],int a){   // 这里接收数组必须是[] 不然就以为是整型；
    a=10000;
    arr[1] = 123;  // 可以直接操作；
}
int main()
{
    printf("Hello, World!\n");
    int a=123;
    int arr[4] = {1,2,3,4};
    func(arr,a);
    printf("%d %d",a,arr[1]); // 123 123
    return 0;
}
// 都是传值   但是一个传的是地址 一个传的是数值； 地址也是一个值；
```





## 二维数组的引用问题 --- 指针；

``````shell

cat >> ceshi.c <<EOF
int main(void){

    int a[3] = {1,2,3};
    int* p = a;
    printf("%d %d %d",(*p),*(p+1),a[2]);
}
EOF
##  prinft(); 要用双引号 格式问题；
## 在cmder 中只有使用 右键复制才会有文本格式换行啥的；
# 二维数组

cat >> ceshi1.c <<EOF
int main(void) {
	int a[2][3] = {
		{1,2,3},
		{4,5,6}
	};
	int* p = a;
	int* p1 = a[1];
	printf("%d %d %d %d \n",p,*(p+2),*(p1+2),a[2][3]);
}
EOF
``````







