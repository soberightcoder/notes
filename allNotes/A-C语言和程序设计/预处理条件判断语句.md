# 预处理条件判断语句



## 基础的的宏定义

>在预处理的时候做替换；
>
>* \#define pi 3.14 取消宏！
>* \#undef pi   取消宏！



`````c
#include <stdio.h>
#include <stdlib.h>

/****
 * 预处理语句 宏定义 + 条件预处理语句！
 * 
*/
//后面不要加;
//变量发生在运行阶段，宏可以加快代码的运行速度，操纵系统内核的写法里面会有很多宏！！！
#define pi 3.14

int main() 
{

    printf("%f\n",pi);
    #undef pi
    printf("%f\n",pi);
    exit(0);
}

repif.c:17:19: error: 'pi' undeclared (first use in this function)
   17 |     printf("%f\n",pi);
`````







## 预处理条件判断语句！

>* \#ifndef  EXTRA_H__
>* \#endif
>* \#ifdef EXTRA_H__
>* \#else
>* \#elif
>* \#if 0
>
>

----

### 防止重复引入

`````c
//repif.h:5:6: error: redefinition of 'test'
//repif.c
#include <stdio.h>
#include <stdlib.h>

/****
 * 预处理语句 宏定义 + 条件预处理语句！
 * 
*/
#include "repif.h"
#include "repif.h"
#include "repif.h"
#include "repif.h"
//后面不要加;
//变量发生在运行阶段，宏可以加快代码的运行速度，操纵系统内核的写法里面会有很多宏！！！
#define pi 3.14
int main() 
{

    test();
    exit(0);
}
`````

`````c
 #ifndef _REPIF_H__


 #define _REPIF_H__
void test() 
{
    printf("repif.h content!");
}

 #endif

//加上了这个条件 才可以重复引入；不会报错！！
`````



### 可以根据定义判断； 是否引入这部分代码！！！



`````c
//1 可以用来注释！！
#if 0
注释
#endif
    
    #include <stdio.h>
#include <stdlib.h>

/****
 * 预处理语句 宏定义 + 条件预处理语句！
 * 
*/
#include "repif.h"
#include "repif.h"
#include "repif.h"
#include "repif.h"
//后面不要加;
//变量发生在运行阶段，宏可以加快代码的运行速度，操纵系统内核的写法里面会有很多宏！！！
#define pi 3.14
// #define TEST
#define DEV
int main() 
{

    // printf("%f\n",pi);
    // #undef pi
    // printf("%f\n",pi);
    

    test();
    //通过宏的定义来判断运行那部分代码！！
#if defined TEST
    printf("test version!");  //
#elif defined DEV
    printf("develop version!");
#endif
    exit(0);
}
    
`````



### debug 调试

`````c
#include <stdio.h>
#include <stdlib.h>

/****
 * 预处理语句 宏定义 + 条件预处理语句！
 * 
*/
#include "repif.h"
#include "repif.h"
#include "repif.h"
#include "repif.h"
//后面不要加;
//变量发生在运行阶段，宏可以加快代码的运行速度，操纵系统内核的写法里面会有很多宏！！！
#define pi 3.14
// #define TEST
#define DEV
#define DEBUG 1 //1 open 0 close

int main() 
{

    // printf("%f\n",pi);
    // #undef pi
    // printf("%f\n",pi);
    

    test();
    //
#if defined TEST
    printf("test version!");
#elif defined DEV
    printf("develop version!");
#endif
//debug 调试功能，是否打印调试信息！！！
#if DEBUG
    printf("debug info");
#endif
    exit(0);
}
`````



# 辅助知识

## 数组和函数的关系

```` c
//array  and func

//当我们使用一个数组，传参的时候，我们既要传递数组的指针，还要传递数组的长度！！！我们才能进行计算！！！

int arrfunc(int *p ,int n) {
    //p代表的是 数组的地址，n是数组的长度！！！
}

//但是返回数组呢？？？
//c语言不能直接返回数组
//肯定是错误的，不能直接返回一个数组！！
int [] func() 
{
	int arr[] = {1,2,3}; //可以加static 数据保存在静态区，所以函数运行完就不会被销毁；
    return arr;
}
int *func1() 
{
    int arr[] = {1,2,3};
    return arr;
}
//可以 放在堆内，然后返回一个指针，然后去取数据；
int *func2() 
{
    // malloc 动态申请内存！！ // 每次调用都会去重新去申请内存；多次运行，内存不释放，内存很快就耗空！！
	int *arr = new  int[] {1,2,3}; // 内存分配在堆里面，相当于c语言的malloc，这些内存需要我们手动释放！！！
    return arr;
}
int main() {
    int *ptr = func2();
    printf("%d\n",ptr[0]); //1 //肯定是错的，因为栈内存已经被销毁了，找不到了！！！
    ptr[0] = 9;
    int *aptr = func2();//两块是不同的内存！！！
    printf("%d\n",ptr[0]); // 1
}
````

