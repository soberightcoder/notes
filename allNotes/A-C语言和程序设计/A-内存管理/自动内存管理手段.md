# 自动内存管理的方式

>GC garbage cyecle and ARC  automatic reference counting 
>
>---
>
>
>
><font color=red>**GC 分配和释放内存的效率和吞吐量要比 ARC 高，但因为偶尔的高延迟，导致被感知的性能比较差，所以会给人一种 GC 不如 ARC 性能好的感觉。**</font>
>
>---
>
>



为了避免堆内存手动管理造成的这些问题，以 Java 为首的一系列编程语言，采用了追踪式垃圾回收（**Tracing GC**）的方法，来自动管理堆内存。这种方式通过**定期**标记（mark）找出不再被引用的对象，然后将其清理（sweep）掉，来自动管理内存，减轻开发者的负担。



而 ObjC 和 Swift 则走了另一条路：自动引用计数（Automatic Reference Counting）。**在编译时，它为每个函数插入 retain/release 语句来自动维护堆上对象的引用计数，当引用计数为零的时候，release 语句就释放对象。php 就是使用的是这种手段；**



我们来对比一下这两个方案。

**从效率上来说，GC 在内存分配和释放上无需额外操作，而 ARC 添加了大量的额外代码处理引用计数，所以 GC 效率更高，吞吐量（throughput）更大**



**但是，GC 释放内存的时机是不确定的，释放时引发的 STW（Stop The World），也会导致代码执行的延迟（latency）不确定。**所以一般携带 GC 的编程语言，不适于做嵌入式系统或者实时系统。当然，Erlang VM是个例外， 它把 GC 的粒度下放到每个 process，最大程度解决了 STW 的问题。



我们使用 Android 手机偶尔感觉卡顿，而 iOS 手机却运行丝滑，大多是这个原因。而且做后端服务时，API 或者服务响应时间的 p99（99th percentile）也会受到 GC STW 的影响而表现不佳。



说句题外话，上面说的 GC 性能和我们常说的性能，涵义不太一样。常说的性能是吞吐量和延迟的总体感知，和实际性能是有差异的，GC 和 ARC 就是典型例子。

<font color=red>**GC 分配和释放内存的效率和吞吐量要比 ARC 高，但因为偶尔的高延迟，导致被感知的性能比较差，所以会给人一种 GC 不如 ARC 性能好的感觉。**</font>





##  问题解决

1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？ 不能，栈上的数据会随着当前线程的函数调用栈而回收，多个线程访问须在堆上开辟。 
2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？ 可以，在当前函数调用栈中，可以新建变量在栈上开辟，顺便分配一个指针指向它，但是注意，这个指针的生命周期只能在当前栈帧中，不能作为返回值给别人用。**也就是说 指针先结束就行？？？**



作者回复: 嗯，@pedro 回答得很详尽了。我补充一下。1. 在多线程场景下，每个线程的生命周期是不固定的，无法在编译期知道谁先结束谁后结束，所以你不能把属于某个线程 A 调用栈上的内存共享给线程 B，因为 A 可能先于 B 结束。这时候，只能使用堆内存。这里有个例外，如果结束的顺序是确定的，那么可以共享，比如 scoped thread（scope thread 范围的线程）；

2. 而同一个调用栈下，main() 调用 hello()，再调用 world()，编译器很清楚，world() 会先结束，之后是 hello()，最后是 main()。所以在 world() 下用指针引用 hello() 或者 main() 内部的变量没有问题，**这个指针必然先于它指向的值结束。**这个两个问题的实质是我们要搞明白哪些东西在编译期可以确定它们的关系或者因果，哪些只能在运行期确定。

