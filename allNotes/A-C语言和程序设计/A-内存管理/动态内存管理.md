# 动态内存管理

>动态内存管理；
>
>为什么需要动态内存管理？
>
>堆上动态的管理；人为的需要数据！！！
>
>auto，放在栈上，static 是放在静态区上；
>
>c语言一定要做到不要有内存泄漏，不要有越界问题，就是一个好的程序员；

---

## 函数：malloc calloc realloc free

>**malloc, free, calloc, realloc - allocate and free dynamic memory;**
>
>原则：谁申请，谁释放！！！ 不然会产生内存泄漏的问题；
>
>alloc  free出现在同一个函数，或者同一个模块当中！

###定义：

>malloc calloc realloc 
>
>成功：非空指针；
>
>失败：NULL；

````c
//malloc  return void*  可以赋值给任何类型的指针； 是一个百搭的指针！！！
//return 代表的开启空间的首地址！！！
int *p = NULL;
p = void* malloc(size_t size); //并不知道你要存放什么样的数据类型，所以只能给你返回一个void*  你可以用任何的数据类型指针来接收；


// void* calloc(size_t nmemb, size_t size);分配多块空间，多个空间的大小size; 同样大小的空间分配n个；一个成员size大小，我要申请n个空间size大小！！


//void* realloc(void *ptr, size_t size) //重新申请内存连续的内存空间；原先的内存空间太大或者太小，重新分配！！！ 


//void free(void *ptr); //释放内存; void *ptr 代表的是地址；首地址；当然可以使用 &a,的形式，当然也可以传指针变量p,都是可以的！！！
````

### code：

`````c
#include <stdlib.h>

void func(int *p, int n) 
{
   // 局部变量的内存泄露，一旦函数结束，只能自己消亡？？？
   // 注意这里和引用的区别！！！
   p = malloc(n);
   if (p == NULL) {
       return -1;
   }
    return ; //void 没有返回
}


int main() {
    int *p = NULL;
    //void * 可以赋值给任何指针 void* 可以直接赋值；
    //不需要强制转换 然后赋值
    //p = (int *)malloc(sizeof(int)); // 要看编译器的版本；
    p = malloc(sizeof(int));
    if (p == NULL) {
        printf("malloc() error!");
        //出错，不应该继续往下运行！！！
        return -1;
    }
    *p  = 10;
    printf("%d\n", *p);
    // malloc 和 free一定要成对出现；
    free(p);
    
 // 动态实现数组
    int num = 5;
    int *p = NULL;
    //申请了一个数组； 实现了一个可变长的数组；
    p = malloc(sizeof(int) * num);
    for (i = 0; i < num; i++) {
        scanf("%d",&p[i]);
    }
    for (i = 0; i < num; i++) {
        printf("%d ", p[i]);
    }
    printf("\n");
    free(p);
    
    
    // malloc 的面试题；
    // 这个程序已经产生了内存泄漏；
    int *p2 = NULL;
    int num1 = 100;
    func(p2,num1);
    free(p2);
    
    
    return 0;
}
`````



`````c
//传值和 传地址的区别？？？
  /**
    * 传地址和传值
    * 这边比较绕；
   */
 void funcp(int *p,int q) {
    q = 3;
    *p = 3;
}
//说白了  也是传的一个地址，不过是指向 指针的地址；
void funcpp(int **p) {
    // p 发生了改变；
    //*p代表的是一级指针的值；
     *p = 111; // 就是二级指针发生改变；
    **p = 123;
}

int main() {
    int *p = NULL;
    int a = 1;
    int b = 2;
    funcp(&a,b);
    printf("%d %d\n",a,b); //3 ,2

    funcpp(&p); //指针的地址要用二级指针来接收
    printf("%d\n",p);//111
}
`````



## free

````c
//code
//

#include <stdio.h>
#include <stdlib.h>
/***
 * free 内存的释放
*/
#define NAMESIZE 32

typedef struct 
{
    int id;
    // 这种方式是比较浪费内存的；
    // 这个地方需要做重构；
    char name[NAMESIZE];
    int math;
    int chinese;
} stu;

typedef struct 
{
    int id;
    char  *name;
    int math;
    int chinese;
} restu;


int main() {

      int *p = NULL;
    //void * 可以赋值给任何指针 void* 可以直接赋值；
    //不需要强制转换 然后赋值
    //p = (int *)malloc(sizeof(int)); // 要看编译器的版本；
    p = malloc(sizeof(int));
    if (p == NULL) {
        printf("malloc() error!");
        //出错，不应该继续往下运行！！！
        return -1;
    }
    *p  = 10;
    printf("%p---->%d\n",p,*p);
    // malloc 和 free一定要成对出现；
    free(p); //仅仅是把内存给释放了；
    //段错误，一定要防止野指针；free之后，要清楚内存；再也没有引用的权限了；
    p = NULL; // 设置为NULL 就不可以引用了；*p去修改是无效的；
    //非常典型的野指针，很危险；有可能别人再用； 
    // *p = 123;
    // printf("%p----->%d\n",p,*p);  //


    //test
    stu stu1 = {1111,"ceshi",11,22};
    printf("%s\n",stu1.name);

    //refactor 重构；
    return 0;
}


//数组太过于死板，不太灵活，需要更多的内存空间！！！


````



# 辅助知识

## 内存溢出和内存泄漏

>内存泄漏和内存溢出！！！

内存溢出：表示程序在申请内存时，没有足够的内存使用，出现了out of memory；

内存泄漏，就是申请内存之后，使用完之后，并没有回收内存，然后就会出现内存的溢出；

一次内存溢出危害可以忽略，但是内存泄漏堆积后果很严重，无论多少内存，迟早被用光！！



## 内存管理 图片



![img](./%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/838ba61ea8d3fd1f963a8963f7f4d21494ca5ffa.jpeg)
