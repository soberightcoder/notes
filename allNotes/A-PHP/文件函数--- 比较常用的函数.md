# 文件函数



## fseek

fseek() 函数在打开的文件中定位。

该函数把文件指针从当前位置向前或向后移动到新的位置，新位置从文件头开始以字节数度量。

如果成功该函数返回 0，如果失败则返回 -1。请注意，移动到文件末尾（EOF）之后的位置不会产生错误。

## 语法

fseek(file,offset,whence)

| 参数   | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| file   | 必需。规定要在其中定位的文件。                               |
| offset | 必需。规定新的位置（从文件头开始以字节数度量）。             |
| whence | 可选。（PHP 4 中新增的）。<br /> 可能的值：SEEK_SET - 设定位置等于 offset。默认。<br />SEEK_CUR - 设定位置为当前位置加上 offset。<br />SEEK_END - 设定位置为文件末尾（EOF）加上 offset（要移动到文件末尾之前的位置，offset 必须是一个负值）。 |
|        |                                                              |

````php
<?php
$file = fopen("test.txt","r");
// read first line
fgets($file);
// move back to beginning of file
fseek($file,0);//重置指针到头部；
````



## fopen





`````php
/**
 * fopen
 * 这里测试需要进入到容器内去；
 * 有没有+  是代表 是否有额外的读写功能；
 */
$dir = __DIR__."/test.txt";
// r+ 并不会清空写，会做一个覆盖写；覆盖原先的内容；
$fr = fopen($dir,"r+");
// $con =  fread($f,10);
$ret = fwrite($fr,"ssssss"); //return int length;//会覆盖写；
var_dump($ret);
fclose($fr);
echo "\n";

//文件不存在会创建；并且会先清空文件；//指针指向开头；
$fw  = fopen($dir, "w+");
$ret = fread($fw,10);
var_dump($ret);//""会清空文件
$ret = fwrite($fw,'wwwwwwww');//指针指向最后？？？？？
// 重置 指针；
fseek($fw, 0);
$ret = fread($fw,5);
var_dump($ret);
fclose($fw);

// a+  append 追加写，文件不存在的时候创建； 指针在末尾；

$fa = fopen($dir, "a+");
$ret = fwrite($fa,"hhhhhh");
fseek($fa, 0); // 也需要去移动指针才能进行操作！！！ fseek();
$ret = fread($fa,11);
var_dump($ret);
fclose($fa);
`````





## fgets





## feof



`````c
/**
 * fgets 逐行输出文本内容；
 */

$fs = fopen($dir, "r");
while(!feof($fs)) {
    $ret = fgets($fs);
    echo $ret;
}
fclose($fs);
`````



## fclose fread f write;





## file_get_conetents  and file_put_contents 

>将整个文件读入一个字符串；
>
>将一个字符写入文件；file_put_contents 
>
>这两个函数只需要路径文件路径就可以了；

`````php

if(file_put_contents($dir, '123')) {
    echo "w+ 清空写入字符串成功";
} 
//success
`````



## 文件锁

>flock文件锁 ；

文件操作系统是在网络环境下完成的，可能有多个客户端用户在同一个时刻对服务器上的同一个文件访问。当这种并发访问产生时，很可能会破坏文件中。例如一个用户正在向文件中写入数据，当还没有写完时，其他用户在这一时刻也向这个文件中写数据，就会造成数据写入混乱。还有，当用户没有将数据写完时，其他用户就去获取这个文件中的内容，也会得到残缺的数据。

在PHP中提供了flock()函数，可以对文件使用锁定机制（锁定或释放文件）。当一个进程在访问文件时加上锁，其他进程要想对该文件进行访问，则必须等到锁定被释放以后。这样就可以避免在并发访问同一个文件时破坏数据。该函数的原型如下：

复制代码代码如下:

````php
bool flock(int handle,int operation[,int&wouldblock])       //轻便的咨询文件锁定
````



第一个参数handle必须是一个已经打开的文件资源，第二个参数opeation也是必需的，规定使用哪种类型。operation可以是以下值之一：
★LOCK_SH取得共享锁定（从文件中读取数据时使用）。
★LOCK_EX取得独占锁定（向文件中写入数据时使用）。
★LOCK_UN释放锁定（无论共享或独占锁，都用它释放）。
★LOCK_NB附加锁定（如果不希望flock()在锁定时堵塞，则应在上述锁定后加上该锁）。**NB no lock  就是不阻塞的意思；**



如果锁定会堵塞的话（已经被flock()锁定的文件，再次锁定时，flock()函数会被挂起，这时成为锁定堵塞），也可以将可选的第三个参数设定为1，则当进行锁定时会阻挡其他进程。锁定操作也可以被fclose()释放。



为了让flock()函数发挥作用，在所有访问文件的程序中都必须使用相同的方式锁定文件。该函数如果成功则返回TRUE，失败则返回FALSE。



---



## php 必须要会的一些函数，也要搞过来；



````php
<?php

declare(strict_types = 1);
session_start();
/**
 * 
 *  */
class TEST90
{
    public static function ceshi($a) {
        echo $a;
        echo "\n";
        echo 'ceshi';
    }
}
//静态方法 也可以这样去调用；  -- 调用静态方法；
call_user_func(array('TEST90','ceshi'),'ccc');
echo "\n";
//str_contain(); php8； 才可以使用！！

// //echo $int ?? 1;
// 初始化；isset == false那么就是1； 初始化了那么就是$int;
$int = 2;
echo $int ?? 1;

echo $int <=> 1;  // 大于1 小于 -1 等于 0；

$str = "abcdefg";

//php8 一下的字符串包含关系；

if (strpos($str,'ab') !== false) {
    echo " contains 包含关系；";
}

//严格模式；


echo "\n";
function ceshi(int $a) :int
{
    echo $a;
    return 0;
}
ceshi(22);

//hash_hmac(); 加密函数； sha256加密呀 等等的！！


//empty  and  isset();
var_dump(empty(array()));// bool  true 空数组可以成立；

class A{

}
// $aobj = new A;
// var_dump(empty($aobj)); // 空对象并不存在！！！

//session();
$token = 'ABCDEFGHIJK';
// echo $_COOKIE['token'];
// echo "<br\>";
// echo $_SESSION['user_id'];
// echo "<br\>";
// if ($_COOKIE['token'] == $token) {
//     echo "token equal";
// }
// echo "<br\>";
// // 傻逼一样 都么有语法错误吗？
// if (!isset($_SESSION['user_id']) || $_COOKIE['token'] != $token || !isset($_COOKIE['token'])) {
//     //no login
//     echo "no login";
//     // header('location:/index.php');
// }

//
echo "if，no login  login in";

//php 函数！！！
echo "\n";
//文件有关的函数
$path = '/ceshi/file.php';
echo basename($path);
echo dirname($path);
//字符串 
//判断文件存不存在
var_dump(file_exists($path));

//fopen();
//fclose();
//fseek();
//fread();
//fwrite();
//file_put_contents();  //
//file_get_contens();
//feof();
//fgets();//获取行的数据；
//scandir();//遍历一个目录里面所有的文件和目录；
//is_dir();
//is_file();

//时间处理函数；
//获取当前时间戳！！
echo time();
//获取当前日期的数组关系；
var_dump(getdate());

// mktime();



/**
 * 日期函数
 * time();
 * date(); 把时间戳转换成日期  日期格式 自己是可以定义的！！！
 * strtotime(); 把英文字符串转换成时间戳吧；
 * date 和 strtotime() 两者可以相互转换,可以相互套娃；
 * getdate(); 把一个时间戳 转换成一个日期数组；
 * set_error_handle();
 * error_report(E_ALL);
 * error_reporting(E_ALL&~E_STRICT&~E_NOTICE);
 */
//中国的时区
date_default_timezone_set('PRC');
strtotime('now +1 month');
//$time = time(); //时间戳  从 1970 1 1
// Y-m-d H:i:s
//echo date('Y-m-d H:i:s',$time);
//echo date('Y-m-d',$time);
//getdate(int $timestamp = time()): array
//var_dump(getdate()); //返回当前时间的数组  可以看到这是一年的第几个周 之类的东西 这一个月的第几个星期 一个月的第几天 一个星期的第几天之类的
var_dump(getdate(time()));// 这两个是相等的；
//echo '89jjj'+1;//但是会给你一个notice 格式不争取之类的
//mktime(时,分,秒,月,日,年)
//echo mktime(23,2,2,1,2,2021); //把日期转换为时间戳
// 把一些字符串格式的日期时间简述 转换成时间戳
// strtotime(string $datetime, int $now = time()): int
//date 和 strtotime 一起来用 还是比较多的；
//echo date( "Y-m-d", strtotime( "2009-01-31 +1 month" ) ); // PHP:  2009-03-03
//echo date( "Y-m-d", strtotime( "2009-01-31 +2 month" ) ); // PHP:  2009-03-31

//SELECT DATE_ADD( '2009-01-31', INTERVAL 1 MONTH ); // MySQL:  2009-02-28
//
//echo strtotime('last weekday');
//echo "<br />";
//echo strtotime('-1 day');
//echo "<br />";
//echo strtotime('now') == time();
//echo "<br />";
//echo strtotime("next Thursday"), "\n";
//echo "<br />";
//echo strtotime("last Monday"), "\n";
//echo "<br />";
//echo strtotime(date('Y-m-d H:i:s'));
//echo "<br />";
//ini_set('display_errors',1); //只针对于本文件

//http_build_query: 将关联数组拼接成URL参数格式  // 这里转成的 URL是对字符串来进行编译的。
//	parse_url: 解析URL为数组   //  把url 转换成一个url的数组 也是分为四部分  scheme host path query 协议 域名 路径 参数
//	parse_str: 解析字符串为多个变量  就是把url参数 解析成多个变量的形式

//字符串；

/**
 * 字符串函数
 * trim(); 删除首尾两端的空白字符（或者其他的字符），ltrim() rtrim()
 * htmlspecialchars 把html转换成实体
 * phpinfo();
 * driname();
 * str_pad(); 填充字符串到指定的长度  *****
 *
 * str_repeat(); 重复一个字符串  单重复0 时候返回空的字符串
 * strrev(); 字符串的反转； *****
 *
 * str_shuffle(); 打乱字符串的顺序 *****
 * prase_url();  scheme host path query
 * strtolower(); 变为小写
 * strtoupper(); 变为大写
 * ucfirst(); 将字符串首字母变为大写  *****
 * ucwords(); 把字符串每一个单词变为大写；
 *
 * explode(); 分割字符串转换成索引数组  *****
 * implode(); 把数组转换成字符串用第一个参数 做拼接 *****
 *
 * str_replace(); 字符串的替换  *******
 * substr(); 字符串的截取 substr(str,start,length); 当start 是负数的时候代表的是从末尾开始  length 默认是到结尾的 负代表到那里结束******
 * 正好 就代表 正序   负号就代表逆序（从字符串结尾开始）
 * strstr();  返回字符串的字串
 * 
 * strpos(); 字符串中 第一次出现的位置；                                      *****
 * strrpos(); 字符串中 最后一次出现的位置；
 * 
 * strcmp  strncmp  是否包含；
 * 
 * strlen                                         *****
 */

// trim();// 删除首位两边的字符；
// str_pad();
// //字符串的截取；
// substr();// 数组的截取；
// substr($str,0,-1);// -1  就是最后的前一个元素； start 整数代表 从头开始，负数代表从末尾开始，length 整数代表长度，负数代表从末尾开始结束的位置；$length  默认是到末尾的；所以  -1 是到末尾的前一个字符；
// explode();//把字符串按照分隔符号 分割成数组；
// implode();// 数组转化成字符串；
// str_replace();// 来做替换；
// strpos();//会判断某个字符串是否包含另外一个字符串；
// // if ($strpos($str1,$str2) !== false)
// strlen();
// ucfirst();//每个单词的首字母变大写；
// str_split()//方法是PHP中用于将字符串分割为一个字符数组的函数 默认是一个；按照字符的数目来进行划分！！！

 /**
 * 数组函数
 * 注意这里数组的操作 都是对value的操作 操作对象都是value
 * array_keys();   获取数组的key值
 * array_key_exists();  ********* 一般不会用 直接 用isset($arr[$key])
 * array_search();// 找到等于某个值的key  *********
 * array_pad($arr,0,4);填充数组到指定长度； //可以做数组的初始化；
 * array_values(); 获取 数组的value
 * array_flip(); 键值互换；
 * in_array();  检查某个值是否在数组  ***********； 关联数组
 * array_push(); //从尾部入栈；   *******
 * array_pop(); //从尾部出栈    *******
 * array_shift(); //从头部移出元素  *****
 * array_unshift(); // 从头部插入元素 *******
 * // 对值的排序  但是a 代表索引也会保持；
 * sort();排序 字符串的排序 都需要用这个；
 * asort();保持 关联来进行的排序；
 * arsort(); 保留索引的倒叙排序；
 * shuffle();打乱数组的顺序 ********
 * array_rand();//随机从数组中取出来一个或多个单元； //数组，随便取出来几个元素；
 * // 效率很慢；
 * array_unique(); 去重；     效率会很低，一般会使用字符串的翻转； ********
 * 
 * array_merge(); 键值对重复的时候，后面覆盖前面的。数字键值对会重新排序； ****** 和 array+array的区别
 * array_comnine(); 合并两个数组 一个做键 一个做值；
 * 
 * count(); 数组的长度  ******
 * array_slice($arr,offset,length,preserve_keys); 从数组中取出来一段 和substr 很类似，preserve_keys是否保持索引，默认是不保持 true是保持；
 * 注意 array_slice() 默认会重新排序并重置数组的数字索引。
 *
 * array_walk(); 定义数组 对数组里面的元素做回调处理   ******
 * array_walk(array,callback); //callback 回调函数会有两个参数 第一个是value 第二个是key  array 参数的值作为第一个，键名作为第二个。
 * 可以使用引用 & 直接修改数组的内容；
 * array_diff(); 差集；
 * array_intersect(); 交集；
 *  ---------------------php 数组指针的操作------------------------------------------------
  * 数组的关于指针的函数；
 * current();
 * next();
 * pre();
 * key();
 * reset()
 * end();
 */


 //字符串的排序；
// $str = 'shssssksksjssi';
// $chars = str_split($str); 
// sort($chars); 
// $result = implode('', $chars); 
// echo $result; // 输出 abcde



//可以看到，通过两次翻转，重复的值被去除，得到了一个去重后的数组。

//需要注意的是，这种方法只适用于值是唯一的情况。如果数组中存在重复的值，只有第一个出现的值会被保留，后续的重复值会被忽略。
// 用 array_flip();来做数据的去重；
//用array_flip来实现array_unique的方法；
$arr1 = [1, 2, 3, 3,3];
//找到重复的；// 
//只能用一个重复的；多个重复会出问题；
function findDulicate(&$elems) {
    var_dump(array_flip($elems));
    
    foreach (array_flip($elems) as $k => $v){
        unset($elems[$v]);
    }
    
}
// findDulicate($arr1);
// var_dump($arr1);//重复的元素只有一个就好了；

// $mid = array_flip($arr1);//重复三个的也会被删除；
// var_dump(array_flip($mid));
//shuffle(); 打乱数组的顺序；
shuffle($arr1);
var_dump($arr1);
//随机取值；
var_dump(array_rand($arr1,2));

//array + array + array_merge(); // 
//array_combine(); 两个数组的合并；并集；
//array_intersect  array_diff 交集  和 差集；

//

$array1  = array( "color"  =>  "red" ,  2 ,  4 );
$array2  = array( "a" ,  "b" ,  "color"  =>  "gressn" ,  "shape"  =>  "trapezoid" ,  4 );
$result  =  array_merge ( $array1 ,  $array2 ); // key 一样的时候保留会做一个覆盖；索引字符串会重新排列；
$result2 = $array1 + $array2;//key 一样的时候 保留前一个数组的key；索引的key也会覆盖；s
print_r ( $result );
print_r ( $result2 );

//差集
//
$array1  = array( "a"  =>  "green" ,  "red" ,  "blue" ,  "red" );
$array2  = array( "b"  =>  "green" ,  "yellow" ,  "red" );
$result  =  array_diff ( $array1 ,  $array2 );
print_r ( $result ); //blue 差集；


//array+ array  array_merge(); 会保留后面的；
//+ 运算符：
//当使用 + 运算符合并两个数组时，如果存在相同的键，那么合并后的数组将保留第一个数组中的值，而忽略第二个数组中的值。
//+ 运算符只保留第一个数组中的键值对，而不会重新索引键。

//array_merge() 函数：
//当使用 array_merge() 函数合并两个数组时，如果存在相同的键，那么合并后的数组将保留最后一个数组中的值。
//array_merge() 函数会重新索引所有的键。

//array_slice() 函数用于从数组中获取指定范围的元素，并返回一个新的数组。


//array_slice(array $array, int $offset, int|null $length = null, bool $preserveKeys = false): array
//$array：要进行切片操作的数组。
//$offset：切片的起始位置。如果是正数，则从数组的起始位置开始计算；如果是负数，则从数组的末尾开始计算。
//$length（可选）：要切片的长度。如果未指定，则切片包含从 $offset 位置到数组末尾的所有元素。
//$preserveKeys（可选）：确定是否保留原始数组的键。如果设置为 true，则保留原始数组的键；如果设置为 false，则重新索引切片后的数组
//对数组做一个切片操作；
// 也是截取最后一个！！！
// length 默认是到最后一个元素；
var_dump(array_slice($arr1,-1));



// 数学运算函数；
pow(); 平方；
sqrt();平方根；
abs();绝对值； ceil();向上取整；
floor();向下取整；
round();四舍五入；
max();
min();
mt_rand(); 随机数；  更高的生成随机数；
rand();
````



