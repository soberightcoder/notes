



# 静态方法和属性和非静态方法属性的区别？





静态方法属于类的所以不需要实例化，就可以被调用；



**就是还在没有实例化的时候静态方法已经分配好内存了；已经给静态属性或者静态方法分配好内存了；**



**而非静态方法 只有实例化的时候才会发配内存；所以在实例化之前访问不到非静态的属性和方法；**



区别：静态方法可以通过“类名::方法名”直接调用；而普通方法需要创建一个实例，也就是new一个对象，然后通过“对象名->方法名”的方式来调用。

**静态方法只能访问类中的静态成员；普通方法可以访问类中的任何成员。**



#### 静态方法

- 静态的内存空间是固定的，相对来说更省资源。
- 创实例的创一个实例就要开辟一个新内存，耗费资源 静态方法属于类所有，类实例化前即可使用；
- 静态方法只能访问类中的静态成员；
- static内部只能出现static变量和其他static方法!而且static方法中还不能使用this等关键字，因为它是属于整个类；
- 静态方法和静态变量创建后始终使用同一块内存，而使用实例的方式会创建多个内存。

#### 普通方法

- 可以访问类中的任何成员， 因为静态方法在类实例化前就可以使用，而类中的非静态变量必须在实例化之后才能分配内存；
- 静态方法效率上要比实例化高，静态方法的缺点是不自动进行销毁，而实例化的则可以做销毁；

#### 主要区别





- **静态方法在创建对象前就可以使用了，非静态方法必须通过new出来的对象调用。**
- 静态方法可以通过 类名::方法名直接调用。普通方法需要创建一个实例，也就是new一个对象，然后通过 对象名->方法名的方式来调用；静态类只能包含静态成员，否则会抛出编译错误；
- 非静态类既可以包含非**静态成员也可以包含静态成员** 静态类是不能实例化,之所以不能实例化,是因为静态类会导致C#编译器将该类同时标记为abstract和sealed,并且编译器不会在类型中 生成一个实例的构造函数，从而导致静态类不能实例化；
- **非静态类可以，并且静态成员的访问只能通过类来进行访问，因为静态成员是属于类的。**







####			设置一个类，这个类有很多对象，很多对象的其中一个属性，属性值是一样的，此时每个对象都有个内存空间去存储属 性值：


	坏处：
		1）空间浪费  （这里就相当于一个全局变量是要浪费空间的；）
		2）如果想要将这个属性值进行修改，需要将所有对象的属性值都修改一遍，操作复杂麻烦,
		
		好处： 修改这个属性之后对于其他的所有的对象都是可见的；只能用静态属性；
			  不需要new；实例化；操作简单;



###静态的特点：

**1）静态方法可以调用静态方法，不能调用非静态方法**
**2）静态方法可以访问静态属性，不能访问非静态属性**
**3）非静态方法可以访问静态的和非静态的**



**静态变量和非静态变量的区别 **

**1）所属不同：静态变量属于类 非静态变量属于对**象

**2）内存存储位置不同：   ****php 中是在符号表中的位置把？？？会有一个static_variables 的符号表；**

**非静态：在堆中·**	
**静态：在方法区中的静态区**

**3）生命周期不同**
**非静态：和对象同寿，对象创建时存在，对象成为垃圾，消亡**  对象我们可以销毁 
**静态：和类同寿，类加载时存在，类消亡时消亡（项目结束了，内存消失）** 但是对象我们没有办法销毁是不是；看成一个全局变量；

** 缺陷：静态数据不宜过多，因为占内存**

**4）访问方式：**
**非静态：对象访问**
**静态：类名和对象名都可以访问**









```php
# 静态属性和方法 并不属于对象；
class  A
{
    public static $a = 10;
    public $b = 1000;
    public static function ceshi() {
        echo "staic funct";
    }
    
    public function ceshi1() {
        echo "a ceshi1 no static";
    }
}

$a = new A; //属于对象的；只能看到对象的；不能看到静态属性；函数看不到是因为没有调用 所以并没有创建函数的符号表；运行完就会销毁；

//var_dump($a);die;

class A#1 (1) {
  public $b =>
  int(1000)
}


```
