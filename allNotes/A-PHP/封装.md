# 封装

> 保护数据和隐藏内部的实现细节；；



对于一个对象,对外界开放一个接口,

调用接口时,内部进行的操作,不需要让外界知道.

隐藏了内部的一些实现细节.

这是对方法的封装.

php封装就是把抽取出来的数据和对数据的操作封装在一起，数据被保护在内部，程序的其他部分只有被授权的操作（方法）才能对数据进行操作。



php提供了三种访问控制修饰符

public 表示全局，本类内部，类外部，子类都可以访问

protected 表示受保护的，只有本类或子类可以访问 可以继承；

private 表示私有的，只有本类内部可以访问 不可以继承；只能在本类内访问；



以上三种修饰符既可以修饰方法也可以修饰属性（变量），方法如果没有访问修饰符则默认是public，成员属性必须指定访问修饰符





### **private 的问题**   这点很重要，一定要做理解；



<font color=red>**如果父类有私有的属性。那么父类的方法只为父类的私有属性服务。子类重写父类方法就会为子类服务；**</font>



**总结：private 的属性和方法，仅仅是对当前类开放；//重写子类方法可以变成自己的方法**

parent::method(); 调用父类的方法；肯定是父类的private属性；



`````php
#第一个列子中 父类的private $sal没有被重写 所以$manager->getSal()这个父类的方法 调用的是父类自己的私有属性$sal 此时内存中有两个$sal，不会发生重写；会有两个zval;

#第二个列子中 父类的protected $sal被重写 $manager->getSal()这个父类的方法 调用已经被重写的$sal 父类的$sal在内存中是不存在的 此时内存中只有一个$sal，会发生重写；一个zval;

//public：外部、家族、自己都可以访问
//protected:家族和自己都可以访问，外部无法访问
//private:自己可以访问，外部和家族都无法访问


class employee{
    protected   $sal=3000;

    public function getSal(){        
        return $this->sal;
    }    
}

class Test extends employee {
    protected $sal = 5000;
    //重写过的方法  重写过 就是我自己的方法了；
    public function getParentSal(){
        //这里返回的是父类的private属性.
        return parent::getSal();
    }    
}

$obj = new Test();
// 都是  5000只有私有变量才会有这个效果；
echo $obj->getSal();
echo $obj->getParentSal();


//只有私有属性才会有这个效果；


`````

 这个问题的一个答案： https://www.cnblogs.com/qiusnay/archive/2012/12/11/2813418.html







`````php
#首先 这个题目就有点问题 因为private属性是不能被继承的

#请仔细看这句话 如果父类有私有的属性。那么父类的方法只为父类的私有属性服务。
下面通过一系列列子来加深理解.
这个例子看起来很奇怪，在子类中重新定义了一个属性$sal，系统却返回了父类的属性。

复制代码
<?
class employee{
    private  $sal=3000;
    //protected    $sal=3000;
    public function getSal(){        
        return $this->sal;
    }        
}

class Manager extends employee {
    protected  $sal=5000;
    
    public function getParentSal(){
        //这里返回的是父类的private属性.
        return parent::getSal();
    }    
}
$manager = new Manager();
echo "PHP ".phpversion()."<br>";
echo $manager->getSal();
echo "<br>";
echo "parent's \$sal ".$manager->getParentSal();

复制代码
程序运行结果：

PHP 5.3.8
3000
parent's' $sal 3000
    
#如果父类中的属性被子类重写了。结果是这样的。注意 第5行的属性定义变成了protected。

复制代码
<?
class employee{
    //private  $sal=3000;
    protected    $sal=3000;
    public function getSal(){        
        return $this->sal;
    }        
}

class Manager extends employee {
    protected  $sal=5000;
    
    public function getParentSal(){
        //这里返回的是父类的private属性.
        return parent::getSal();
    }    
}
$manager = new Manager();
echo "PHP ".phpversion()."<br>";
echo $manager->getSal();
echo "<br>";
echo "parent's \$sal ".$manager->getParentSal();

?>
复制代码
程序运行结果：

PHP 5.3.8
5000
parent's' $sal 5000
第一个列子中 父类的private $sal没有被重写 所以$manager->getSal()这个父类的方法 调用的是父类自己的私有属性$sal 此时内存中有两个$sal
第二个列子中 父类的protected $sal被重写 $manager->getSal()这个父类的方法 调用已经被重写的$sal 父类的$sal在内存中是不存在的 此时内存中只有一个$sal
    
接下来看第三个列子
子类中重写的方法对当前private有效。

复制代码
<?
class employee{
    private   $sal=3000;
    public function getSal(){        
        return $this->sal;
    }    
}

class Manager extends employee {
    private   $sal=5000;
    //重写过的方法  重写过 就是我自己的方法了；
    public function getSal(){        
        return $this->sal;
    }        
    public function getParentSal(){
        //这里返回的是父类的private属性.
        return parent::getSal();
    }    
}
$manager = new Manager();
echo "PHP ".phpversion()."<br>";
echo $manager->getSal();
echo "<br>";
echo "parent's \$sal ".$manager->getParentSal();

?>
复制代码
运行结果

PHP 5.3.8
5000
parent's' $sal 3000
这个列子中子类重写getSal()方法 所以他调用的是子类的属性
如果你注释子类的这一行
//private $sal=5000;
你会发现一个错误：Notice: Undefined property: Manager::$sal in E:\wamp\www\oo\2-5\2-5-3.php on line 14
如果注释掉12行的子类重写方法 那么echo $manager->getSal();得到的结果是 父类的私有属性$sal 3000

打开zend调试状态看看，内存中的情况。注意最下面，有两个$sal 。分别是 3000 和 5000 。

复制代码
<?
class employee{
    private  $sal=3000;    
    public function getSal(){        
        return $this->sal;
    }        
}
class Manager extends employee {
    protected  $sal=5000;    
    public function getParentSal(){
        return $this->sal;
    }    
}
$manager = new Manager();
echo "PHP ".phpversion()."<br>";
echo $manager->getSal();

?>
复制代码
程序运行结果：

PHP 5.3.8
3000
将父类的属性$sal 改成 protected ，子类重写了父类的属性。在内存中只有一个 $sal 。

复制代码
<?
class employee{
    protected  $sal=3000;    
    public function getSal(){        
        return $this->sal;
    }        
}
class Manager extends employee {
    protected  $sal=5000;    
    public function getParentSal(){
        return $this->sal;
    }    
}
$manager = new Manager();
echo "PHP ".phpversion()."<br>";
echo $manager->getSal();

?>
复制代码
程序运行结果：

PHP 5.3.8
5000
如果你学过java，你会觉得这一切都是很难理解的。
在Java中当子类被创建时，父类的属性和方法在内存中都被创建，甚至构造函数也要被调用。
PHP5不是这样，PHP5调用父类用的是parent:: 而不是 parent-> ，这足以说明PHP5不想在内存中让父类也被创建。PHP5想让继承变的比Java更简单。
适应下就好。
`````



