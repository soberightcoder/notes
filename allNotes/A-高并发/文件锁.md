# 文件锁

>flock

---



## 了解一下阻塞和非阻塞；



阻塞和非阻塞是在计算机编程中用来描述程序在等待某个操作完成时的行为方式。

1. 阻塞：**当程序发起一个阻塞式操作时，它会等待操作完成后再继续执行后续的代码。**在这期间，程序会被挂起，无法执行其他任务。阻塞通常用于需要等待某个事件发生后再继续执行的情况，比如等待用户输入、等待文件读取完成等。
2. 非阻塞：**当程序发起一个非阻塞式操作时，它会立即返回，不会等待操作完成。**程序可以继续执行后续的代码，同时定期检查操作是否完成。非阻塞通常用于需要同时处理多个任务或者需要保持响应性的情况，比如同时处理多个网络连接、同时监控多个文件等。

在实际编程中，选择使用阻塞还是非阻塞取决于具体的需求和场景。阻塞式操作通常更简单直观，但可能会导致程序在等待时无法执行其他任务；而非阻塞式操作可以提高程序的并发性和响应性，但需要额外的代码来处理操作完成前的等待和轮询。

**在网络编程中，阻塞和非阻塞也经常用来描述套接字（socket）的行为。阻塞套接字在进行 I/O 操作时会阻塞程序的执行，而非阻塞套接字在进行 I/O 操作时会立即返回，需要程序自行处理操作完成前的等待和轮询。**



## 阻塞不占用cpu

阻塞操作通常不会占用 CPU。当程序执行阻塞操作时，它会被挂起，不会占用 CPU 资源。相反，CPU 可以用于执行其他任务，直到阻塞操作完成并且程序恢复执行。

举例来说，当程序执行阻塞式的文件读取操作时，它会等待文件系统完成读取并将数据返回给程序。在这段等待的时间里，程序不会占用 CPU 资源，而 CPU 可以用于执行其他任务。一旦文件读取完成，程序会恢复执行，继续使用 CPU 资源。

**因此，阻塞操作不会占用 CPU，而是让 CPU 可以用于执行其他任务。这也是为什么在需要等待某些事件完成后再继续执行的情况下，通常会选择使用阻塞操作，以避免浪费 CPU 资源。**



----

## flock

`````php
// 进程1； index8.php;

<?php

/**
 * 文件锁的问题
 * 进程1
 */
// 锁住的是这个文件；
$f = fopen('test.txt','w+');

if (flock($f, LOCK_EX)) {
    //拿到锁；
    fwrite($f,'locks in file indedx8!!');

    //lock release
    sleep(10);
    flock($f, LOCK_UN);
    // 锁其实资源的文件名；
    echo "release locks\n";
} else {
    echo "flock ux error!!";
}

fclose($f);

`````





````php
<?php

/**
 * 文件锁 flock
 * 注意 最好 在一个容器里面测试；
 */


/**
 * 文件锁；
 * w+ 指针一开始是指向最开始；
 * 注意这里不同的文件名，不同的资源 就是对应不同的锁；// 所以使用的时候首先要生成不同文件名的文件！！
 */
// echo $path;
// die;
$f = fopen('test.txt', 'w+');
// 先判断一下是否可以抢到锁；
// var_dump(flock($f,LOCK_UN));
// die;
$count = 0;
// 去拿锁；
//默认情况下，该函数将堵塞直到获得锁；
// if (flock($f, LOCK_EX)) {
//     //拿到锁；
//     fread($f, 1024);
//     echo "拿到了锁！";
//     //lock release ;
//     flock($f,LOCK_UN);
// }
// 不加锁会看到数据的变化，会导致数据不一致的问题；

//非阻塞 去拿锁；没拿到锁 就会跳过 执行下面的；
if (flock($f, LOCK_EX | LOCK_NB)) {
    //拿到锁；
    fread($f, 1024);
    echo "拿到了锁！";
    //lock release ;
    flock($f,LOCK_UN);
}
//微妙 ，1s = 1000毫秒，= 1000000微秒；
// usleep(5000);
// $count++;
// $filestat = fstat($f);
// $filesize = $filestat['size'];
// echo "尝试的次数num:" . $count . "size:" . $filesize . "try locks!!\n";
// 
// flock($f, LOCK_UN);
echo "no block huoqu suo ;";
fclose($f);



/**
 *类似于 redis 的blpop的区别一个是阻塞的一个是非阻塞的；
 * BLPOP 和 LPOP 都是 Redis 中用于从列表（List）中获取元素的命令，但它们之间有一些重要的区别。

*LPOP：从列表的左侧（头部）弹出一个元素，并返回该元素的值。如果列表为空，则返回 nil。

*BLPOP：阻塞式的从列表的左侧（头部）弹出一个元素，并返回该元素的值。如果列表为空，BLPOP 命令会一直阻塞等待，直到有元素可弹出或者超时。

*主要区别在于阻塞行为。BLPOP 是阻塞式的，如果列表为空，它会一直等待直到有元素可弹出或者超时；而 LPOP 是非阻塞的，如果列表为空，它会立即返回 nil。
 * 
 *  */


//shell
//先后台执行index8.php
php index8.php &
//然后后面在执行 index9.php
php index9.php  //注意会被阻塞；
````

