# redis 和 mysql的原子性问题

>注意的是redis是单线程的，mysql 是多线程的；
>
>[]: 
>
>

---

## 为啥redis 和mysql 都有可能会发生超卖问题；

`````php
//redis 单线程 也就是说 ，一次只能运行一个命令；
// 不使用lua 为啥会出现超卖的问题；
if (get('stock') > 0) {
    // 应该也是进来多个线程，
	incr('stock');
}

## 1 client 1  
get('stock') > 0
## client 2 
get('stock') > 0
## client 3 
get('stock') > 0
## client 1
incr('stock')
## client 2
incr('stock')
## client 3
incr('stock')
//上面是单线程执行顺序，就是在client  1 减库存之前，client2 client3 执行了判断库存数命令；当客户端数大于库存数的时候，那么就会出现超卖的问题；
// 所以可以使用lua 语言的原子性来保证；数据的一致性；
// 肯定可以的呀；
$script2 = <<<EOF
    local key = KEYS[1]
    local stock =  redis.call('get',key)
    if (tonumber(stock) > 0)
    then
        redis.call('decr',key)
        return true
    else
        return false
    end
EOF;
`````



````php
//mysql
//这里会出现超卖是因为多个线程；
if (select stck from t where id = 1> 0) {
    // 判断大于0 进来的线程数，大于库存数，就会出现超卖的问题；
    update set stock= stock -1 from t where id =1;
}

//解决：
if (select stock from t where id = 1 for update > 0) {
    //加锁；只有一个线程获取到锁 然后做-1 然后提交事务，释放锁，下一个线程去做-1； 这样肯定不会存在炒卖的问题；
    update set stock = stock - 1 from t where id =1;
}
````

