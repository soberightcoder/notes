#  高并发 幂等性处理

>**幂等性，同样条件下，请求一次或者n次，结果都是一样的；结果是一样的；**
>
>**防重复，防止重复提交，但是不要求结果一样；**
>
>---
>
>**需要幂等性设计的场景：**
>
>* **用户，连点，会请求多次；**
>
>* **请求失败，会重试几次，会产生重复的数据；**
>* **kakfa消息队列，重复消费的问题；**
>
>---
>
>**sql出现的场景：**
>
>* **一般出现在 insert into sql 语句中；**
>* **update table_name set column_name = new_value - \$diff where id = 1;**   
>
>-----
>
>
>
>幂等性处理的方式：
>
>> **前提：前端可以用设置，按一下变灰，不允许再请求；只请求一次；**
>
>1. 

---



### token + redis

> 高并发的情况肯定不行的；

````php
//要使用token和Redis来实现幂等性，你可以将token作为操作的唯一标识，并将其存储在Redis中。在每次操作之前，首先检查Redis中是否存在该token，如果存在则表示该操作已经执行过，可以直接返回结果，如果不存在则执行操作并将token存储到Redis中。

///以下是一个使用token和Redis实现幂等性的示例代码：

import redis

# 连接到Redis
r = redis.Redis(host='localhost', port=6379, db=0)

def is_token_exist(token):
    # 检查token是否存在
    return r.exists(token)

def process_request_with_idempotency(token, request_data):
    if is_token_exist(token):
        # 如果token存在，表示操作已经执行过，直接返回结果
        return "Operation already processed"
    else:
        # 执行操作，并将token存储到Redis中
        # 这里假设执行操作的函数为process_request(request_data)
        result = process_request(request_data)
        r.setex(token, 3600, "processed")  # 将token存储到Redis并设置过期时间
        return result
//在这个示例中，我们首先定义了一个is_token_exist函数来检查token是否存在于Redis中。然后，我们定义了一个process_request_with_idempotency函数，该函数接收token和请求数据作为参数。在函数内部，我们首先检查token是否存在，如果存在则直接返回结果，如果不存在则执行操作，并将token存储到Redis中，以确保该操作不会被重复执行。
//通过这种方式，你可以利用token和Redis来实现幂等性，确保相同的操作不会被重复执行。
            
            
 //php  生成唯一token的方法
 // uniqid() + userId + rand(0,9000);  加一个随机数；或者加内存信息  get_use_memory();
````



### 唯一索引

`````php
// 当插入的字段有唯一索引的时候，可以防止幂等性；
// insert 高并发的时候可以；
`````



###  状态机 

`````php
//update  set status = 'paid' where orderid = 1 and status = 'not pay';
// 一般用户 update 的判断； 这个完全是可以的；
`````



###分布式锁

`````php
// redis 来实现的分布式锁   或者使用 mysql 的分布式锁 ，详情看下面详解！！！
// 都是解决并发的问题；
`````



### 乐观锁

`````php
//乐观锁；怎么实现幂等性？？？ 这个解决的是并发问题，数据的不一致性问题把； 怎么去解决幂等性问题呀；卧槽！！！
// 不能去解决 幂等性 但是可以配合高并发的token+redis 使用；才能保证幂等性；
// 实现了，并发不需要加锁，因为加锁也会有性能损耗问题！！！
//获取版本信息；
$version_id = select versionId from t where orderId = 1;
//
$new_value = $old_value - $diff;
//
$new_versionid = $version_id + 1;
//
update set value = $new_value，versionId = $new_versionId  where orderId = 1 and versionId = $version_id;

//乐观锁机制通常用于解决并发更新的问题，它通过比较数据版本号或时间戳来确保在更新数据时不会发生冲突。虽然乐观锁可以帮助处理并发更新的情况，但它并不能直接解决幂等性问题。

//幂等性是指对同一操作的多次执行所产生的效果与一次执行的效果相同。在Web开发中，幂等性通常用于确保对同一请求的多次执行不会产生不一致的结果。乐观锁并不直接解决这种情况，因为它主要关注并发更新而不是请求的幂等性。

//要解决幂等性问题，通常需要在应用程序的设计和实现中考虑以下几点：

//设计RESTful API时，使用HTTP方法的语义来确保幂等性。例如，GET和PUT方法应该是幂等的，而POST方法通常不是幂等的。
//在数据库操作中，使用唯一标识符或者其他方式来确保同一操作的多次执行不会产生不一致的结果。
在应用程序逻辑中，通过设计合适的业务逻辑和数据处理流程来确保幂等性。
因此，虽然乐观锁可以帮助处理并发更新的问题，但它并不能直接解决幂等性问题。要解决幂等性问题，需要在应用程序的设计和实现中考虑其他方面的解决方案。
`````



### redis  setnx  加一个锁

``````php
//setex  加锁 来防止并发；锁的是某个用户的接口；insert into  要用这个办法来解决！！！lock； 

### redis
##set key value NX (XX) EX; NX 只有不存在的才会设置；
//
set __METHOD__.:user_id  NX EX 2; //锁主这个用户的接口订单接口2s的幂等性！！！
``````





###  select insert

``````php
// 但是也不能保证高并发一致性的问题；
//select + insert 先去查询 然后再进行插入；来保证数据的一致性；
//比如 每一个用户只能购买一单；可以通过select 来判断 有没有生成过订单，没有生成才能进行插入；
``````



---

## 高并发请求下的幂等请求怎么满足

>注意： 在高并发的条件下，设计防幂等性表，高并发下，一定要加锁，单纯的token redis 是没有办法解决这个问题的；
>
>核心： 一锁 + 二判+ 三更新；
>
>可以使用redis的分布式锁；

----

``````php
// 普通锁和分布式锁的区别？？？ //
//当然 可以使用mysql的悲观锁；
//for update 
//高并发的情况下；
$diff = $_GET['diff'];
$old_stock = select stock from t where goods_id  = 1;
$new_stock = $old_stock - $diff;

if (select stock form t where goods_id = 1  > 0) {
   //
    update set stock = $new_stock where goods_id = 1;
}

// 高并发的情况下；
 $stock = select stock form t where goods_id = 1 for update;
if ($tock > 1) {
    update set stock = $stock - 1 where id = 1;
}

$new_stock = $stock - $diff;
update set stock = $new_stock where goods_id = 1;

update set stock = stock- $diff where goods_id = 1;  //更新的区别？？
//redis 实现的分布式锁！！！
``````
