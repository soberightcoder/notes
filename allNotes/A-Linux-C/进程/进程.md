# 进程基本知识

>* 进程基础内容；
>* 进程通信
>* 守护进程
>
>已经进入到多进程阶段；
>
>1. **pid processid**
>2. **进程的产生fork vfork(基本已经废弃);**
>3. **进程的消亡及释放资源;**
>4. exec 函数族的使用；
>5. 用户权限及组权限； 身份是怎么切换的；
>6. 观摩课，解释器文件；
>7. system(); 函数
>8. 进程会计；并不是重点！了解
>9. 进程时间；
>10. **守护进程**   **需要会写 守护进程**
>11. **系统日志**

---

## 进程基础

###pid 

``````c
//类型 pid_t pid ，16位的有符号的整型数；可以typedef 转换成其他类型；
//ps 这个命令；
//常用组合
ps -axf 
ps -axm
//进程标识是顺次向下使用！！！ 会继续往下走；不会回头，除非全部使用完；
// getpid();当前进程的进程号；
 //getppid(); 获取父进程parentid ppid 
//-x  详情，会展示，进程的内存占用比和占用的cpu，和，进程状态；
``````



### 进程产生；

>**fork  叉子；**

#### fork

`````c
//pid_t fork(void);  fork : create a new process by duplicating the calling process.  复制；包括memorycopy； 一模一样！！连执行到的位置都一样；复制自己的方式产生一个进程；

//retrun value  
//下面一定要做绝对路径的挂载，不然会出问题；
G:\cwebsite 
$ docker run -tid --name centosmap -v G:\cwebsite\linuxc\:/linuxc/ centos:7 bash
1f0fa0d58dde35ce4ddee7d44bf6058c3e9211bdd7a366d66e22a9769b8d122c
//code 
    
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main() {
    pid_t pid;
    //这个肯定是父进程；
    //终端是行缓存
    // > 全缓冲，并不会刷新缓冲区；所以父子缓冲区里面都会有一个begin；
    printf("[%d]:Begin!\n",getpid());
    //刷新所有的流,fork之前要刷新流！！
    fflush(NULL); /*!!!!!!!!*/
    //fork之后代码一式两份；都会运行；连运行的位置你都是知道的；
    pid = fork(); // 他给他的父进程和子进程返回不同的值；
    //fail -1 
    if (pid < 0) {
        perror("fork fail");
        exit(1);
    }
    /**
     * 不要区凭空去猜测，父子进程谁先调度；
     * 由调度策略来决定，那个进程先运行，所以不能凭空猜测；
    */
    if (pid == 0) {
        // 子进程
        printf("[%d]:child is working\n",getpid());
    } else {
        // 父进程；
        /**
         *sleep的移植性有问题！
        */
        // sleep(1);
        printf("[%d]:Parent is working\n",getpid());
    }
    //end! 打印两次；
    printf("[%d]End!\n", getpid());
    //程序停在那里；//可以使用 ps -axf 查看详情；
    //ps -aux 
    // ps -ef 
    // getchar();
    exit(0);
}
#if 0
//不加 fflush(NULL)的结果！！
[root@fce7a0a3deef linuxc]# ./fork > /tmp/out
[root@fce7a0a3deef linuxc]# cat /tmp/out 
[199]:Begin!
[199]:Parent is working
[199]End!
[199]:Begin!
[200]:child is working
[200]End!
#endif
    
    
    

    
    
    
//ps -axf  阶梯关系；init 是祖先进程！！!并不是所有进程的父进！！
 [root@fce7a0a3deef /]# ps -axf
  PID TTY      STAT   TIME COMMAND       
  169 pts/2    Ss     0:00 bash
  183 pts/2    R+     0:00  \_ ps -axf   
  137 pts/1    Ss     0:00 bash
  167 pts/1    S+     0:00  \_ ./fork    
  168 pts/1    S+     0:00      \_ ./fork
    1 pts/0    Ss+    0:00 bas
`````

fork 之后父子进程的区别：
注意理解关键字，duplicating  意味着copy，克隆，一摸一样；
区别：  **fork 返回值不一样，pid和 ppid是不同的，未决信号和文件锁不继承，资源利用量清0，**

init进程，是所有进程的祖先进程；==== 女娲；pid = 1；



fork的写实复制；

`````c
//多进程编程

//僵尸状态和孤儿状态
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

/**
 * 查找质数；
 * 多进程编程；
 * time .\primer1 查看运行时间程序的运行时间；
 * zombie
 *   求质数的普通计算方式,只能被1和本身整除的数；
*/
/**
 *  开启多进程编程；
*/
#define LEFT 30000000
#define RIGHT 30000200
int main()
{
    pid_t pid;
    int i, j;
    for (i = LEFT; i <= RIGHT; i++) {
        pid = fork();
        if (pid < 0) {
            perror("fork()fail");
            exit(1);
        }
        /**
         * 下面是子进程干的事情；
        */
        if (pid == 0) {
            // 标记位
            int mark = 1;
            for (j = 2; j < i / 2; j++) {
                //能被整除
                if (i % j == 0) {
                    mark = 0;
                    break;
                }
            }
            if (mark)
                printf("[%d][%d]is a primer\n",getpid() , i);
                //进程一定要安全退出；不然会产生无数个进程；
                //这里父亲成没了，这个些子进程会成为孤儿进程，等待init进程来收尸；
            sleep(1000);
            exit(0);
        }
    }
    //父进程，exit(0);执行完会退出；
    //因为子进程退出的时候，父进程，需要父进程去收尸；所以会产生很多zombie僵尸进程;僵尸进程是占用pid的，pid资源是有限的，所以我们应该杀死僵尸进程；
    // sleep(1000);
    exit(0);
}
`````



### 进程的消亡及释放资源

>**怎么去收尸；**

`````c
//wait();
//waitpid();
// wait, waitpid, waitid - wait for process to change state 
RETURN VALUE
  wait():  on  success,  returns the process ID of the terminated  
       child; on error, -1 is returned.
           
 // pid_t wait(int *status); //阻塞模式；。一定是阻塞的；
  //options参数的设置；非阻塞模式；
 // pid_t waitpid(pid_t pid, int *status, int options);
  
//pid 值问题
        The value of pid can be:

       < -1   meaning  wait  for any child process whose process group  
              ID is equal to the absolute value of pid.  //绝对值；

       -1     meaning wait for any child process.  //任何一个子进程都行；

       0      meaning wait for any child process whose  process  group  
              ID is equal to that of the calling process. //进程分组，同组来做同一个操作；用户分组也是这个意思；可以做一个权限的修改，就是为了方便 批量修改；//同组的子进程；

       > 0    meaning  wait for the child whose process ID is equal to  
              the value of pid.
 //waitpid(-1,&status,0); 收如任意一个就行；
 //code
  //写一下 primer0.primer1和primer2； 
  //res compare 结果比较！！！
  // 注意开启多个进程并不是 成倍数增加
sys     0m0.000s
[root@fce7a0a3deef process]# time ./primer1 > /dev/null

real    0m0.012s
user    0m0.000s
sys     0m0.000s
[root@fce7a0a3deef process]# time ./primer2 > /dev/null

real    0m0.519s
user    0m0.910s
sys     0m0.000s
[root@fce7a0a3deef process]# time ./primer0 > /dev/null

real    0m0.963s
user    0m0.950s
sys     0m0.000s
//res  primer3 res
[root@fce7a0a3deef process]# time ./primer3 > /dev/null

real    0m0.555s
user    0m0.960s
sys     0m0.000s
`````



### 交叉分配和分块法 --- 三个算法的优化；上面 primer0 primer1 primer2

>主要的三种算法：
>
>* 分块法；
>* 分叉分配
>* 进程池算法；
>
>大部分时间使用，交叉分配，因为更加随机；
>
>池类算法；进程池算法；
>
>**注意primer算法，当是质数的时候时间复杂度高；不是质数的时候复杂度低；**

`````c
//进程池算法；
//进程池去抢任务；池类算法肯定会牵扯到竞争问题！！！竞争和冲突问题；

//code 使用交叉分配来实现算法！！！

// 交叉分配算法；
//就是把这一些计算分配几个进程去计算！！！
//
//primer3--code
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
/**
 * 查找质数；
 * 多进程编程；
 * time .\primer1 查看运行时间程序的运行时间；
 * zombie
 *   求质数的普通计算方式,只能被1和本身整除的数；
*/
/**
 *  开启多进程编程；
 *  进程交叉分配的方式！！
*/
#define LEFT 30000000
#define RIGHT 30000200
//交叉分配
#define N 3
int main()
{
    pid_t pid;
    int i, j, n, k;

    for (n = 0; n < N;n++)
    {
        //产生四个进程
        pid = fork();
        if (pid < 0) {
            perror("fork()fail");
            //for循环里面的fork 当报错的时候，fork 失败，我们要为已经创建的子进程收尸！！
            //不然会产生孤儿进程；
            // for (k = 0; k < n; k++)
            //     wait(NULL);

            exit(1);
        }
        /**
         * 下面是子进程干的事情；
        */
        if (pid == 0) {
            for (i = LEFT + n; i <= RIGHT; i += N) {
                // 标记位
                int mark = 1;
                //子进程 处理；
                for (j = 2; j < i / 2; j++) {
                    //能被整除
                    if (i % j == 0) {
                        mark = 0;
                        break;
                    }
                }
                if (mark) {
                    printf("pid:[%d]---[%d]is a primer\n", n, i);
                }
                //N代表的是第几个进程！！！
                //进程一定要安全退出；不然会产生无数个进程；
                //这里父亲成没了，这个些子进程会成为孤儿进程，等待init进程来收尸；
                // sleep(1000);
            }
            exit(0);
        }
    }
    //父进程，exit(0);执行完会退出；
    //因为子进程退出的时候，父进程，需要父进程去收尸；所以会产生很多zombie僵尸进程;僵尸进程是占用pid的，pid资源是有限的，所以我们应该杀死僵尸进程；
    // sleep(1000);
    //    //比如你个进程是一个daemon守护进程，fork的子进程执行完之后，父进程不去收尸，那么会形成僵尸进程，占用pid资源！！！

    for (n = 0;n < N; n++)
        wait(NULL);
    exit(0);
}
//res 
[root@fce7a0a3deef process]# time ./primer3 > /dev/null

real    0m0.555s
user    0m0.960s
sys     0m0.000s
`````



