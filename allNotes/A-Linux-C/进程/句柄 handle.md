# **php - 句柄 handle**

>**php 对象的句柄！！handle;**
>
>Q：
>
>`````c
>//对象在堆内的变化并不是固定的，会变化，并不是简单的引用！！！
>$a  = new  A:
>$b = $a;
>$b = 0;
>//$a 依然还是那个对象对吗？
>
>
>//和引用规则不符合呀！！！
>$c = 99;
>$d = &$a;
>$d = 0;
>$c = 0;
>//php通过符号表来查询这个变量的；
>`````
>
>



`````c
#include <stdio.h>
#include <stdlib.h>
/**
 * php 对象句柄的处理
 * handle的处理
 *  //这边还是有疑问呀；
 * //
 * 在C++中，要访问一个对象，通常可以建立一个指向对象的指针。但是在很多具体的应用中，直接用指针代表对象并不是一个好的解决方案 [3] 。
 * C/C++ 什么是句柄
句柄是一个指向指针的指针。

一个指向指针的指针保存的是另一个指针的地址，我们可以通过第一个指针来找到另一个指针，然后通过另一个指针访问到具体的数据。

Windows 需要经常在物理内存和虚拟内存之间来回移动数据。数据被移动意味着他的地址发生变化，如果我们还用之前的地址来访问它，那么肯定是会出错的。如何解决这个问题？

为了解决这个问题，Windows 系统专门腾出一块内存空间来保存数据在内存中的地址变化，Windows 每次移动数据偶，都要把数据的新地址告知这个内存空间来保存。而记录地址变化的这块内存空间的地址是保持不变的。

我们把这个不变的地址叫作句柄。我们便可以通过改句柄找到数据的最新地址，然后访问该数据。

当然，每次重启程序的时候，Windows 操作系统分配的句柄都是不一样的，就像每次抽奖抽到的号码不同一样，但也有可能，不过几率太小。
*/
int a = 22;
int *q = &a;
void handle(int **p) {
    //php的句柄的赋值的赋值
    p = &q;
    //对句柄的操作；
    //php $a->
    // **p = 33;
    printf("%d\n",**p);//22已经改变了句柄；

}
/**
 * php句柄的处理
 * 二级指针的值时不变的，但是一级指针的值会发生变化；
 * 
*/
int b = 111;
void php_handle( int ** const p) {
    // p = &q; //F
    //指针常量，不能修改；p的值；一直指向同一个内存空间！！！
    //对象的zval内存地址不是固定不变的会发生改变；但是句柄的地址并不会变化；这也是使用句柄的原因；
    *p = &a;//改变句柄里的指向zval的地址；但是不该指针的地址并不会被改变！！！
    //访问zval；
    //$a = new A;
    // $a->ceshi = 22;
    //修改zval的内容就是下面的操作；
    **p = 22;//修改变量值，就是我们的访问；
    //$b = $a;
    int **q = p;
    // $b = 0;
    //修改符号表，指向一个新的，0的zval并不会影响到$a 这个对象！！！！
}
int main() {
    int i = 11;
    int *p = &i;
    handle(&p);
    printf("%d\n",i);
    /**
     * php句柄的概念
    */
    php_handle(&p);
    exit(0);

}

#if 0
$a = new A;
$b = $a;
$b = 2;//这个就是上面的p 改变指向的zval，现在指向long 为2的zval;
你的应用程序往往要对对象(数据文件, 自定义的数据结构等)做一些操作, 而句柄可以简单地理解为是指向这些对象的一个指针. 在你的程序启动之后, 这些对象在内存中并非是一成不变的, 一方面由于处理器调度等原因, 另一方面现在的操作系统大多基于虚拟内存空间, 在这种情况下, 内存管理器会经常来回移动对象, 以此来满足当前运行的需要, 那如果说我们寻找对象的方式仅仅是依靠一个指针 ---- 指向了一个固定的内存地址, 那么显然是没办法应对不断变化的实际内存, 所以, 句柄可以说是一个指向指针的指针, 它本身虽然没有直接指向对象, 但是可以通过它来获知对象在内存上的变动情况, 然后间接地获取对象

也就是说, 实际对象在内存里的地址通常是不固定的, 而固定的句柄则描述了相应对象在内存里的位置

在C语言里有的是指向结构体的指针
#endif
`````



