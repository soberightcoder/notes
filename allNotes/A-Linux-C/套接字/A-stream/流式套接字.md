# 流式套接字

>传输特点：
>
>* 一对一，点对点
>* 安全可靠传输，并不是不丢包？？ 丢包是一直存在的现象！
>* 

---

C端主动端

1. 获取socket  socket
2. 给socket取的地址 （可以省略） bind
3. 发送连接  connect建立连接
4. 收/发消息 send/recv 发送消息；
5. 关闭



S端

1. 获取socket  socket()

2. 给socket取得地址//   bind()

   绑定ip地址就是我们可以接收那些ip地址的连接；

3. socket置为监听模式  listen(); 监听这个文件描述符 

   tcp 为什么要监听？？listen 模式？

4. 接收连接    accept

5. 收/发消息  send  recv

6. 关闭  close

---

## 函数

>

`````c
//func -- recv
NAME
       recv, recvfrom, recvmsg - receive a message from a socket

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       ssize_t recv(int sockfd, void *buf, size_t len, int flags);

       ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *src_addr, socklen_t *addrlen);


//bind
SYNOPSIS
       #include <sys/socket.h>

       int bind(int socket, const struct sockaddr *address,
              socklen_t address_len);
// man 7 ip 
// sockaddr 的形式！！   
struct sockaddr_in {
               sa_family_t    sin_family; /* address family: AF_INET */
               in_port_t      sin_port;   /* port in network byte order */
               struct in_addr sin_addr;   /* internet address */
           };

   /* Internet address. */
           struct in_addr {
               uint32_t       s_addr;     /* address in network byte order */
           };


//listen
NAME
       listen - listen for connections on a socket

SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>
	// backlog 全连接队列的大小！！！
       int listen(int sockfd, int backlog);

//accept
NAME
       accept, accept4 - accept a connection on a socket

SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>
		//接收一个C端的地址！！！
       int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
    
 //send
  NAME
       send, sendto, sendmsg - send a message on a socket

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       ssize_t send(int sockfd, const void *buf, size_t len, int flags);

       ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);



//   int sprintf(char *str, const char *format, ...);给一个字符串变量赋一个字符串的值！！！

`````





## 四次挥手

time wait 四次回收的状态；相当于式强制杀死！！！ ctrl +c 杀死！！！ close(sd) 肯定不会做到！！！

端口还在占用！！！所以不能再次占用了；

// 这个socket 设置可以解决 端口占用的请款，可以立即释端口，然后占用！！

![1684290887852](./%E6%B5%81%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97.assets/1684290887852.png)

````c
// man 7 socket 去查看不同的选项！！
int val = 1;
//传输 注意val 这边为啥传递值，是因为由很多类型，包括结构体，所以要统一来传递指针！
// 传输长度就是为了区分 是那种数据类型！！！！
if(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&val,sizeof(1))) {
    perror("setesockopt");
    exit(1);
}
````



`````c
//code --- code 
#include <stdlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>     
#include <sys/socket.h>
#include <stdint.h>
#include <arpa/inet.h>

#include "proto.h"
#define IPSTRSIZE 40
#define BUFSIZE  1024
static void server_jobs(int sd) 
{
    char buf[BUFSIZ];
    int len;
    //返回的数据大小；
    len = sprintf(buf,FMT_STAMP,(long long)time(NULL));
    if (send(sd,buf,len,0) < 0)
    {
        perror("send()");
        exit(1);
    }
}
int main()
{
    int sd,new_sd;
    struct sockaddr_in saddr, caddr;
    socklen_t caddr_len;
    char ipstr[11];
    sd = socket(AF_INET, SOCK_STREAM, 0/**IPPROTO_TCP,*/ /**IPPROTO_SCTP*/);
    if (sd < 0)
    {
        perror("socket()");
        exit(1);
    }

    // 绑定ip地址，接收方 就是我们要接收那些ip的连接；从那些监听的式那个端口；
    // saddr数据赋值
    saddr.sin_family = AF_INET;
    // 要在网路里传输要转换为网络字节顺序；
    saddr.sin_port = htons(atoi(SERVER_PORT));
    // point ip === > int ip; 点式字符串ip，转换成整型ip；
    inet_pton(AF_INET, "0.0.0.0", &saddr.sin_addr);
    if (bind(sd, (void*)&saddr, sizeof(saddr)) < 0)
    {
        perror("bind()");
        exit(1);
    }
    //监听这个端口，sd去监听这个端口；
    if (listen(sd, 200) < 0)
    {
        perror("listen()");
        exit(1);

    }
    //接收信息
    caddr_len = sizeof(caddr);
    while (1) {
        //accrpt 生成一个新的sd；
        new_sd = accept(sd, (void*)&caddr, &caddr_len);
        if (new_sd < 0) 
        {
            perror("accept()");
            exit(1);
        }
        inet_ntop(AF_INET,&caddr.sin_addr,ipstr,IPSTRSIZE);
        printf("Clinet:%s:%d\n",ipstr,ntohs(caddr.sin_port));
        server_jobs(new_sd);
    }
    //close 关闭并不一定能运行到！！
    close(sd);
    exit(0);
}

//telnet 来进行测试！！！

`````

## client

函数

`````c
//connect
NAME
       connect - initiate a connection on a socket

SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>
//
       int connect(int sockfd, const struct sockaddr *addr,
                   socklen_t addrlen);
//recv 
NAME
       recv, recvfrom, recvmsg - receive a message from a socket

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       ssize_t recv(int sockfd, void *buf, size_t len, int flags);

       ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *src_addr, socklen_t *addrlen);
`````

````c
/stream/client.c
#include <stdlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>     
#include <sys/socket.h>
#include <stdint.h>
#include <arpa/inet.h>

#include "proto.h"

// nc == net client 就是客户端！ 就是写一个客户端！
int main(int argc, char** argv)
{
    int sd;
    struct sockaddr_in caddr;
    socklen_t caddr_len;
    long long stamp;
    //因为这里是一个结构体，所以指针是最好用的！！！
    FILE* fd;
    if (argc < 2)
    {
        fprintf(stderr, "参数个数太少\n");
        exit(1);
    }
    sd = socket(AF_INET, SOCK_STREAM, 0);
    if (sd < 0)
    {
        perror("socket()");
        exit(1);
    }
    caddr.sin_family = AF_INET;
    caddr.sin_port = htons(atoi(SERVER_PORT));
    //server端的ip;
    inet_pton(AF_INET, argv[1], &caddr.sin_addr);
    //bind(); // 随机端口；
    caddr_len = sizeof(caddr);
    //我们要用connect
    if (connect(sd, (void*)&caddr, caddr_len) < 0)
    {
        perror("connect()");
        exit(1);
    }
    /**
     * io真的很重要！！！
    */
    //流式的操作，对文件描述都的操作转换成对io的操作！！
    //这才是一切皆文件的原理！！
    fd = fdopen(sd, "r+");
    // printf("%p\n",fd);
    if (fd == NULL)
    {
        perror("fdopen()");
        exit(1);
    }
    //读取io到stamp 
    //     int fscanf(FILE *stream, const char *format, ...);
    //等同于 == recv  == 接收就是读取；文件描述符里的内容！！！
    //      ssize_t recv(int sockfd, void *buf, size_t len, *int flags);
    //这里卡住了？？
    //这里有问题 scanf 这里卡住了！！！
    //注意这里一定不要加回车符号！！！！
    if (fscanf(fd, "%lld", &stamp) < 1)
        fprintf(stderr, "Bad format!\n");
    else
        fprintf(stdout, "stamp = %lld\n", stamp);
    //这样关闭文件描述符就可以了
    fclose(fd);
    //不用这个来关闭文件描述符；
    //recv();
    // close(sd);
    exit(0);
}
````



# 辅助知识

vim ; 

有时候一段一段的移动游标会比较方便.我们可以用 {,},(,) 来达到这些功能

{ (左大括号) 跳到上一段的开头
} (右大括号) 跳到下一段的的开头.

( (左小括号) 移到这个句子的开头
) (右小括号) 移到下一个句子的开头

[[ 跳往上一个函式
]] 跳往下一个函式



## 函数 man 3 fprintf

`````c
fscanf在使用时需要注意其返回值，是否成功读取数据。否则可能没读成功，但是不报错，程序继续执行，用上一轮读取的数据继续操作。可能造成程序最终结果错误。

 1 #include<stdio.h>
 2  
 3 int main()
 4 {
 5     int a, b;
 6     FILE* fin = fopen("in.txt", "r");
 7     for(int i=0; i< 2; ++i) {
 8         int r = fscanf(fin, "%d %d", &a, &b);
 9         printf("%d\n", r);
10         printf("%d %d\n", a, b);
11     }
12     return 0;
13 }

当in.txt 为：

1 2

则输出结果：

2
1 2
-1
1 2

可见第一次循环时，fscanf成功读取2个数据，返回值为2。第二次循环时，fscanf并未读取到数据，返回值为-1，且变量a、b值并未改变。在实际代码中，此时程序继续执行，可能出现无法预料的后果。

故使用fscanf时，最好检查一下其返回值是否成功读取预期的数据。  
    //起码要大于1，才表示能取到数据！！

`````

