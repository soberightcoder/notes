# 动态报式套接字





----

## code

```````c
//proto.h
#ifndef PROTO_H__
//端口一定要超过 1024  前1024 一般都是系统端口；
#define PROTO_H__

#define RCVPORT "1989"
//固定大小式不行的
// #define NAMESIZE 11
//udp 推荐的大小,512 -8（udpheader头）- 8（math ，chinese 总共8个字节！）
#define NAMEMAX (512-8-8)
struct msg_st
{
    uint32_t math;
    uint32_t chinese;
    uint8_t name[1]; // char * 注意不能使用这个 不能传输一个指针，因为是不同的服务器，同样的地址，保存的内容并不是一致的！！
}__attribute__((packed));

#endif
```````



````c
//snder.c
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>     
#include <sys/socket.h>
#include <stdint.h>
#include <arpa/inet.h>
#include <string.h>
#include "proto.h"

/***
 * 服务端地址
*/
int main(int argc,char *argv[]) 
{
    int sd,size;
    //要发送的数据；
    struct msg_st *sbufp;
    //要发送的ip地址的格式；
    struct sockaddr_in raddr;
    //./snder ip name
    if (argc < 3) 
    {
        fprintf(stderr,"Usage......!参数数量不对");
        exit(2);
    }
    if (strlen(argv[2]) > NAMEMAX) {
        fprintf(stderr,"name too long!");
        exit(1);
    }
    //注意name只有一个字节，加上字符串的长度，但是要加\0所以正好是够的！！kk
    size = sizeof(struct msg_st) + strlen(argv[2]);
    sbufp = malloc(size);
    if (sbufp == NULL) {
        perror("malloc()");
        exit(1);
    }
    sd = socket(AF_INET,SOCK_DGRAM,0);
    if (sd < 0) {
        perror("socket()");
        exit(1);
    }

    //bind(); 发送端 可以省略；

    strcpy(sbufp->name,argv[2]);  // 单字符的不需要考虑大小端的问题！！！
    // 
    sbufp->math = htonl(rand()%100);
    sbufp->chinese = htonl(rand()%100);

    raddr.sin_family = AF_INET;
    raddr.sin_port = htons(atoi(RCVPORT));
    // raddr.sin_addr = inet_pton(atoi(argv[1]));
    inet_pton(AF_INET, argv[1],&raddr.sin_addr);
    //size 就是动态msg_st的结构体的大小！！
    if(sendto(sd,sbufp,size,0,(void *)&raddr,sizeof(raddr)) < 0) {
        perror("sendto()");
        exit(1);
    }
    puts("OK!");
    close(sd);
    exit(0);
}

````



`````c
//rcver.c
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>     
#include <sys/socket.h>
#include <stdint.h>
#include <arpa/inet.h>

#include "proto.h"

#define IPSTRSIZE 40
//主动端必须要有监听环节，也就是bind 绑定端口环节，而发送端，可以是随机取一个发送的！！！
int main() 
{
    
    int sd,size;
    //laddr local addr 
    //raddr remote addr
    struct sockaddr_in laddr,raddr;
    struct msg_st *recvbufp;
    socklen_t raddr_len;

    char ipstr[IPSTRSIZE];

    //申请内存；
    //我不知道要传输多大的数据，但是就是按照最大空间开辟就好了！！
    size =  sizeof(struct msg_st) + NAMEMAX - 1;// -1 就是因为，结构体里面是 1
    recvbufp = malloc(size);
    if (recvbufp == NULL) {
        perror("malloc()");
        exit(1);
    }
    sd = socket(AF_INET,SOCK_DGRAM,0/**IPPROTO_UDP**/);
    if (sd <  0) {
        perror("socket() fail!");
        exit(1);
    }
    laddr.sin_family = AF_INET;
    //因为post要在进行传输 所以我们要做转换！！ 转换成网络字节 ；
    laddr.sin_port = htons(atoi(RCVPORT));
    //万能地址，any address 可以匹配任何的地址；
    //万能地址；
    inet_pton(AF_INET,"0.0.0.0",&laddr.sin_addr);
    // (void *)//??????是什么意思？？？ 转换成void *的形式，那么他就可以用任何的指针形式来接收了对嘛？
    // 后面看一下！！！！
    if (bind(sd,(void *)&laddr,sizeof(laddr)) <0 ) {
        perror("bind()");
        exit(1);
    }

    /**!!!!!*/
    raddr_len = sizeof(raddr);
    while (1)
    {
        recvfrom(sd,recvbufp,size,0,(void *)&raddr,&raddr_len);

        inet_ntop(AF_INET,&raddr.sin_addr,ipstr,IPSTRSIZE);
        printf("---message -from %s:%d---\n",ipstr,ntohs(raddr.sin_port));
        printf("NAME=%s\n",recvbufp->name);
        printf("NAME=%d\n",ntohl(recvbufp->math));
        printf("NAME=%d\n",ntohl(recvbufp->chinese));
    }
    close(sd);
    exit(0);
}

`````



![image-20230516164131419](./%E5%8A%A8%E6%80%81%E6%8A%A5%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97.assets/image-20230516164131419.png)

# 辅助知识

## 数组的动态扩容



````c
//对数组来做动态扩容

struct msg_st
{
   int math;
   int chinese;
   char name[1];
};

struct msg1_st
{
    int math;
    int chinese;
    char *name;
};

//两种动态扩容的方法；

//1 method
int size;
struct msg_st *p;
//下面的长度是 算上字符串的尾0的；
size = sizeof(struct msg_st) + strlen(argv[2]);  //需要申请的内存大小！！！
p = malloc(size);
if(p == NULL) 
{
    perror("malloc()");
    exit(1);
}
//赋值
strcpy(p->name, argv[2]);



//2  method
#define MAX 20
struct msg1_st msg1;
char *p;
size = MAX;
p = malloc(size);
if (p == NULL) 
{
    perror("malloc()");
    exit(1);
}


````



````c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
/**
 * 测试，动态扩容的问题；
*/

struct msg1_st
{
    int math;
    int chinese;
    char *name;
};
#define MAX 20

int main() 
{
    char *p;
    struct msg1_st msg1;
    p = malloc(MAX);
    if (p == NULL) 
    {
        perror("malloc()");
        exit(1);
    }
    // 字符串的地址给他赋值；
    p = "ssss";// p是指针变量，所以可以改变p的指针变量；
    //但是 char *p = "ss";//指针常量；但是可以改变指针的指向！
    // char a[] = "sssss"; //a是指针常量，所以不能通过改变指向来赋值，只能 通过hh桉树strcpy来赋值！！！
    // strcpy(p,"abcdedd");
    msg1.chinese = 90;
    msg1.math = 1;
    msg1.name = p;

    printf("chinese:%d\n",msg1.chinese);
    printf("math:%d\n",msg1.math);
    printf("name:%s\n",msg1.name);
    exit(0);
}
````

