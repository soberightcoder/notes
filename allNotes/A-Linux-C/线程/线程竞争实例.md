# 线程竞争实例

>竞争的问题；--- 原子操作！！！
>
>十字路口，东西南北的通行，红绿灯其实就是通行的协议！约定好的protocol 协议！
>
>我们怎么样？ 保证车辆不相撞！！！

`````c
//code

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>
/**
 * 查找质数；
 * 多线程编程！！
 * time .\primer0 查看运行时间程序的运行时间；
 * zombie
 *   求质数的普通计算方式,只能被1和本身整除的数；
*/
#define LEFT 30000000
#define RIGHT 30000200
// 
#define THRNUM (RIGHT - LEFT + 1)
//竞争产生的原因，&i 就一块地址；201个线程共同用 1个地址！！
static void* thr_prime(void* p) {
    //p = &i;// 转换为void* 来接收；void *
    // 这里p 是void *p 但是你传递的数据是 int * 
    //p依然是void 所以你要使用 ，必须要强转为int *来使用；
    int i, j, mark;
    // 接收到的是void *p 可以
    i =  *(int *)(p);//void *p  转换成int * 然后取值！！
    // 标记位
    mark = 1;
    for (j = 2; j < i / 2; j++) {
        //能被整除
        if (i % j == 0) {
            mark = 0;
            break;
        }
    }
    if (mark)
        printf("[%d]is a primer\n", i);
    pthread_exit(NULL);
}

int main()
{
    int i, err;
    pthread_t tid[THRNUM];
    for (i = LEFT; i <= RIGHT; i++)
    {	// 
        err = pthread_create(tid + (i - LEFT), NULL, thr_prime, &i);
        if (err)
        {
            // 注意细节，说不定我已经创建了200个线程，但是创建第201个的时候出错了！！
            // 
            fprintf(stderr, "pthread_create():%s\n", strerror(err));
            exit(1);
        }
    }
    //收尸收尸200个线程！
    for (i = LEFT; i <= RIGHT; i++) {
        pthread_join(tid[i - LEFT], NULL);
    }

    exit(0);
}

//会出现线程竞争的问题！！
`````





`````c
// code----解决线程竞争问题！！
//G:\cwebsite\linuxc\posix\thread\primer1.c
//使用强制转换！来解决，线程竞争的问题！！！
//这种强制转换会出现警告！！！ 
// 会存在，失真的问题！！多注意！！！
//primer1.c:24:9: warning: cast from pointer to integer of different size [-Wpointer-to-int-cast]
//   24 |     i = (int)p;
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>
/**
 * 查找质数；
 * 多进程编程；
 * time .\primer0 查看运行时间程序的运行时间；
 * zombie
 *   求质数的普通计算方式,只能被1和本身整除的数；
 * 
 * 
 * 解决 线程竞争的问题！！！
*/
#define LEFT 30000000
#define RIGHT 30000200
// 
#define THRNUM (RIGHT - LEFT + 1)
// 201 个线程 公用一个地址&i;
static void* thr_prime(void* p) {
    int i, j, mark;
    // i =  *(int *)(p);//void *p  转换成int * 然后取值！！
    i = (int)p;
    // 标记位
    mark = 1;
    for (j = 2; j < i / 2; j++) {
        //能被整除
        if (i % j == 0) {
            mark = 0;
            break;
        }
    }
    if (mark)
        printf("[%d]is a primer\n", i);
    pthread_exit(NULL);
}

int main()
{
    int i, err;
    pthread_t tid[THRNUM];
    for (i = LEFT; i <= RIGHT; i++)
    {
        err = pthread_create(tid + (i - LEFT), NULL, thr_prime, (void *)i);
        if (err)
        {
            // 注意细节，说不定我已经创建了200个线程，但是创建第201个的时候出错了！！
            // 
            fprintf(stderr, "pthread_create():%s\n", strerror(err));
            exit(1);
        }
    }
    //收尸收尸200个线程！
    for (i = LEFT; i <= RIGHT; i++) {
        pthread_join(tid[i - LEFT], NULL);
    }

    exit(0);
}
`````





````c
//code --primer2.c更加优雅的解决方案！！
// 冲突的原因是201个i使用同一个空间，只要保证201个i指向不同的空间就好了！！！
//primer2.c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>
/**
 * 查找质数；
 * 多进程编程；
 * time .\primer0 查看运行时间程序的运行时间；
 * zombie
 *   求质数的普通计算方式,只能被1和本身整除的数；
 * 
 * 
 * 解决 线程竞争的问题！！！
*/
#define LEFT 30000000
#define RIGHT 30000200
// 
#define THRNUM (RIGHT - LEFT + 1)
// 201 个线程 公用一个地址&i;
 typedef struct thr_arg_st
{
    int n;
} thr_arg;

static void* thr_prime(void* p) {
    int i, j, mark;
    // i =  *(int *)(p);//void *p  转换成int * 然后取值！！
    i = ((thr_arg *)p)->n;
    // 标记位
    mark = 1;
    for (j = 2; j < i / 2; j++) {
        //能被整除
        if (i % j == 0) {
            mark = 0;
            break;
        }
    }
    if (mark)
        printf("[%d]is a primer\n", i);
    //有线程的返回值;
    pthread_exit(p);
}
int main()
{
    int i, err;
    pthread_t tid[THRNUM];
    thr_arg *p = NULL;
    void *ptr;
    for (i = LEFT; i <= RIGHT; i++)
    {
        // 动态申请内存！！!! 注意看一下把
        p = malloc(sizeof(p));
        if (p == NULL) {
            perror("malloc");
            exit(1);
        }
        p->n = i;
        err = pthread_create(tid + (i - LEFT), NULL, thr_prime, p);

        if (err)
        {
            // 注意细节，说不定我已经创建了200个线程，但是创建第201个的时候出错了！！
            // 
            fprintf(stderr, "pthread_create():%s\n", strerror(err));
            exit(1);
        }
    }
    //收尸收尸200个线程！
    for (i = LEFT; i <= RIGHT; i++) {
        pthread_join(tid[i - LEFT], &ptr);
        free(ptr);
    }

    exit(0);
}
````



## 竞争故障

````c
//code--- 
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
/***
 * 线程竞争实例
 * 开启20个线程对一个文件进行读取+1操作；
*/

/**
 * 虚拟机 虚拟到单核上，是顺序执行的；；；所以不会产生竞争问题！！！
 * 线程执行的比较短！！！所以相当于顺序执行的
 * 
 * 单核的原因！！
*/
#define THRNUM 20
#define FNAME "./out"
#define LINESIZE 1000

static void* func(void* p)
{
    FILE* fp;
    char linebuf[LINESIZE];
    fp = fopen(FNAME, "r+");
    if (fp == NULL) {
        perror("fopen fail");
        exit(1);
    }
    // 
    fgets(linebuf, LINESIZE, fp);
    // 仅仅 + 1；
    //加一个sleep 相当于是多个线程都拿到了数据，都去写；所以这个值仅仅+1；
    sleep(1);
    fseek(fp, 0, SEEK_SET);
    fprintf(fp, "%d\n", atoi(linebuf) + 1);
    fclose(fp);
    pthread_exit(NULL);
}

int main()
{
    int i, err;
    pthread_t tid[THRNUM];

    for (i = 0; i < THRNUM;i++) {
        //回填 ，必须要传指针；
        err = pthread_create(tid + i, NULL, func, NULL);
        if (err) {
            fprintf(stderr, "pthread_create() error!");
            exit(1);
        }
    }

    for (i = 0; i < THRNUM;i++) {
        //根据pthread_t来进行收尸；
        pthread_join(tid[i], NULL);
    }
    exit(0);
}
````

## 互斥量

> **其实类似于加锁！！！**
>
>**//code  // 限制一段代码的运行！！！**
>
>20个人只能一个人来拿到锁，拿到锁，才能去操作，拿不到锁，不能去操作；
>
> mutex互斥量函数：
>
>pthread_mutex_init(); 互斥量初始化！！
>
>pthread_mutex_destory(); 互斥量销毁！
>
>lock 函数：限制代码的执行；
>
>pthread_mutex_lock() 阻塞；
>
>pthread_mutex_trylock() 非阻塞；
>
>pthread_mutex_unlock();解锁！！



````c
//code  // 限制一段代码！！
//互斥量的使用
//code
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
/***
 * 线程竞争实例
 * 开启20个线程对一个文件进行读取+1操作；
*/

/**
 * 虚拟机 虚拟到单核上，是顺序执行的；；；所以不会产生竞争问题！！！
 * 线程执行的比较短！！！所以相当于顺序执行的
 *
 * 单核的原因！！
*/

/**
 * 添加互斥量 来解决 线程安全，并发访问的问题！！！
*/
#define THRNUM 20
#define FNAME "./out"
#define LINESIZE 1000

static pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;

static void* func(void* p)
{
    FILE* fp;
    char linebuf[LINESIZE];
    fp = fopen(FNAME, "r+");
    if (fp == NULL) {
        perror("fopen fail");
        exit(1);
    }
    pthread_mutex_lock(&mut);
    fgets(linebuf, LINESIZE, fp);
    // 仅仅 + 1；
    //加一个sleep 相当于是多个线程都拿到了数据，都去写；所以这个值仅仅+1；
    sleep(1);
    // 一秒增加一个；一共增加 20个；
    fseek(fp, 0, SEEK_SET);
    fprintf(fp, "%d\n", atoi(linebuf) + 1);
    fclose(fp);
    pthread_mutex_unlock(&mut);
    pthread_exit(NULL);
}

int main()
{
    int i, err;
    pthread_t tid[THRNUM];

    for (i = 0; i < THRNUM;i++) {
        //回填 ，必须要传指针；
        err = pthread_create(tid + i, NULL, func, NULL);
        if (err) {
            fprintf(stderr, "pthread_create() error!");
            exit(1);
        }
    }

    for (i = 0; i < THRNUM;i++) {
        //根据pthread_t来进行收尸；
        pthread_join(tid[i], NULL);
    }
    pthread_mutex_destroy(&mut);
    exit(0);
}
````



`````c
// 面试题！！！google
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>
/**
 * 开启四个线程向stdout分别输出abcd四个字符；
 * 每个线程分别输出 abcd四个字符！！！
 * 要求四个线程，顺序输出，先输出aaa然后bbb然后ccc然后dddd；
*/

#define THRNUM 4
/**
 *先输入谁，根据调度器的调度策略来决定！！
 * 多核，你会看到一下子调用多个线程；
 *
*/
/**
 * next 组成循环！
*/

/**
 *互斥量，锁的是代码，并不是一个变量！！！
*/
static int next(int n) {
    if (n + 1 == THRNUM)
        return 0;
    return n + 1;
}
//创建了四把锁！
static pthread_mutex_t mut[THRNUM];
/***
 * 想象有四个线程运行这一份代码！！！
*/
static void* printabcd(void* p) {
    int i;
    i = (int)p;
    int  c = 'a' + i;
    //  ssize_t write(int fildes, const void *buf, size_t nbyte);
    while (1)
    {
        //所有的线程都要阻塞到这里；
        //这也是前面需要加锁的原因！
        //然后所有的线程都会卡在这里；
        pthread_mutex_lock(mut + i);
        write(1, &c, 1);
        pthread_mutex_unlock(mut + next(i));
    }
    pthread_exit(NULL);
}
int main()
{
    int i, err;
    pthread_t tid[THRNUM];
    // 0 1 2 3/4
    for (i = 0;i < THRNUM;i++)
    {
        //初始化锁！！ // 初始化锁；
        pthread_mutex_init(mut + i, NULL);
        //加四把锁！
        pthread_mutex_lock(mut + i);
        // 给每一个线程加一把锁；
        err = pthread_create(tid + i, NULL, printabcd, (void*)i);
        if (err) {
            fprintf(stderr, "pthread_create()fail:%s\n", strerror(err));
        }
    }
    //时钟信号 ，5秒会把main线程杀死；
    pthread_mutex_unlock(mut + 0);

    alarm(5);
    for (i = 0;i < THRNUM;i++) {
        pthread_join(tid[i], NULL);
    }
    exit(0);
}


#if 0
result  
abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd
#endif

`````



# 辅助知识

## sleep --- 调试语句！！竞争的调试方法--可以使用sleep

>sleep 存在两个问题：
>
>* 等什么？
>* 等多久？ 



## void \* 问题

`````c
#include <stdio.h>
#include <stdlib.h>

/**
 *  void * void 指针问题；
 * 空的数据类型； NULL；
 * void * 类型的指针来接收其他类型的指针，接收到，使用的时候需要强制类型转换！！！
*/

static void func(void *p) {
    //当你用void * 来赋值其他类型的指针的时候，当需要的时候需要强制转回去；
    int i;
    i = *(int *)p;
    printf("%d\n", i);
}
/**
 * void * 数据可以用 任意的数据类型来接收
*/

int main()  
{
    int a = 1;
    func(&a);
    int *p = NULL;
    //return void * 可以用任何类型的指针来接收！！
    p = malloc(sizeof(int));
    if (p == NULL) 
    {
        printf("malloc error!");
        exit(1);
    }
    *p = 10;
    printf("%p-->%d\n",p,*p);
    free(p);
    p = NULL;
    exit(0);
}
`````



## 一个进程 可以创建多个线程

>上面一个进=main进程内创建了201个线程，资源使用关系：
>
>* **代码段是共用的！函数的代码段是共用的！**
>* **他们的栈是独立的；**
>
> **注意： 一个进程最多创建多少个线程！！**

````shell
## ulimit -a
## 32位操作系统！！ 
## 主要是看栈的大小！！！
##[root@19de37f7be96 thread]#
##user limit 用户限制！！！
ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7908
max locked memory       (kbytes, -l) 82000
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1048576
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) unlimited
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
````

