# 线程的终止

>三种的终止方式：
>
>* 线程 从启动例程返回，返回值就是线程的退出码；
>
>* 线程可以被同一进程中的其他线程取消；
>
>* 线程调用pthread_exit()函数，线程的结束，相当于进程的exi(); 如果是最后一个线程，那么进程也会退出！！！
>
>  

----

## pthread_exit() pthread_join()

>###pthread_exit()
>
>线程的退出！！！
>
>实现线程栈的清理；
>
>return null； 不会做线程的清理；
>
>### ptread_join(); 
>
>类似于进程的wait 

`````c
//retval  返回值！！！
void pthread_exit(void *retval);

// 线程的收尸
// main 线程回去给线程收尸，等待给线程收尸！！！
// 线程给我们的返回值，**retval;
int pthread_join(pthread_t tjread, void **retval);


//code

`````



`````c
//code
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>
/**
 * 线程的流程
 * 加入收尸环节
 * 线程的调度，取决于调度器的策略！！
*/
int a = 1;
static void* func(void* p) {
    puts("Thread is working!");
    //这里返回值是void * 所以必须返回为NULL；
    // return NULL;
    // 建议使用pthread_exit();来退出；
    // 没有返回值NULL
    pthread_exit(&a);
}

int main() {
    //线程标识
    int err;
    pthread_t tid;
    puts("Begin!");
    //线程还没有调度，但是进程已经结束了！！！
    err = pthread_create(&tid, NULL, func, NULL);
    if (err) {
        //失败；
        fprintf(stderr, "pthread_create() error:%s\n", strerror(err));
        exit(1);
    }
    //收尸环节
    void *p = NULL;
    pthread_join(tid, &p);
    printf("%d\n", *(int *)p); // 他说他返回的是void * 指针；所以我们就给做一个转换成
    puts("End!");
    exit(0);
}

#if 0
res
Begin!
End!
Thread is working!

没有sleep(10);
在线程没有调度的时候 进程已经被销毁；

可能出现的情况
1. thread is working 在begin 和 end 中间！！！
2. thread is working 出现在end之后
#endif
`````



## 栈的清理

>pthread_cleanup_push();
>
>pthread_cleanup_pop();

`````C
   #include <pthread.h>

       void pthread_cleanup_push(void (*routine)(void *),
                                 void *arg);
       void pthread_cleanup_pop(int execute);

//这两个函数不是函数  是两个宏！！？？？
//必须要成对出现！！！


//code
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
/**
 * 栈的清理
*/
// 所以任何的指针都可以接受赋值NULL；
// #define NULL ((void*)0)
static void cleanup_func(void *p) {
    puts(p);
}
static void * func(void *p) 
{
    puts("Thread is working!");
    // 压入栈；
    pthread_cleanup_push(cleanup_func, "cleanup:1");
    pthread_cleanup_push(cleanup_func, "cleanup:2");
    pthread_cleanup_push(cleanup_func, "cleanup:3");
    puts("push over!");
    pthread_cleanup_pop(1);//执行你钩子函数先执行的是3
    pthread_cleanup_pop(1);
    pthread_cleanup_pop(1);
    pthread_exit(NULL);
}

int main() 
{
    int err;
    pthread_t tid;
    puts("Begin!");
    err = pthread_create(&tid, NULL, func, NULL);
    if (err) {
        fprintf(stderr, "pthread_create():%s\n", strerror(err));
        exit(1);
    }
    pthread_join(tid, NULL);
    puts("End!");
    exit(0);
}

#if 0
//res
Begin!
Thread is working!
push over!
cleanup:3
cleanup:2
cleanup:1
End!
#endif
`````

## 线程的取消选项！

>在一个一万层的二叉树，在树中，查找某一个值！！！
>
>找到了之后取消；
>
>pthread_cancel();
>
>pthread_setcancelstate()

`````c
  #include <pthread.h>
// 线程取消
//取消有两种状态：允许和不允许！
//允许取消又分为：异步cancel，推迟cancel（默认的）->推迟至cancel点，再响应！
//cancel点：posix定义的cancel点，都是可能引发阻塞的系统调用！
// cleanup_push 并不是cancel点，所以并不会被取消，推迟到 cancel点才会取消！！！
       int pthread_cancel(pthread_t thread);
//先 取消再收尸！！！

//---------------------------------------------------------------
//设置是否允许取消！！
    #include <pthread.h>

       int pthread_setcancelstate(int state, int *oldstate);

//  设置取消方式！！
       int pthread_setcanceltype(int type, int *oldtype);

// 本函数什么都不做，就是一个cancel点！！！
 void pthread_testcancel(void);
`````

## 线程分离

>pthread_detach();

````c
//detach 分离线程，不能在进行收尸了！！！ pthread_join收尸会报错！！！
//你已经分离了，所以就不会分裂了；
int pthread_detach(pthread_t thread); 
````

