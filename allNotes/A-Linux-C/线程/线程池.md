# 线程池  --- 任务池

>不要用200个线程去计算！！
>
>会有栈大小，pid，的限制！！！
>
>inode 文件描述符的限制；

---

## 任务池代码

>code 
>
>main 线程就是任务的上游！
>
>num 就是任务池；
>
>四个线程去抢任务池里的任务！！ 是任务的下游；
>
>下面代码的cpu占用率会很高！因为，还是一个忙等的版本；
>
>上游在不断的加锁解锁，来查看数据有没有被拿走；num == 0
>
>下游要不断的加锁解锁，来查看数据有没有发布；num !=0
>
>可以使用异步！！！

``````c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>


/**
 * 线程池；--- 忙等阶段
 * 无论是发送任务池，还是线程抢夺任务的人，都要求去忙等，等待别人修改num得值；
 * 任务池;
 * num > 0 有任务  需要线程池 去抢任务
 * num = 0 无任务  main 线程向去添加任务；添加要计算的数据；
 * num = -1 代表退出；
 * 会有三个线程来抢人物；
 * 抢任务，肯定先要加锁，然后再抢任务！！！
*/

static int num = 0;

static pthread_mutex_t mut_num = PTHREAD_MUTEX_INITIALIZER;

#define THRNUM 4
#define LEFT 30000000
#define RIGHT 30000200

static void* func(void* p)
{
    int n = (int)p;
    int i, j, mark;
    //加锁；
    while (1) {
        pthread_mutex_lock(&mut_num);
        while (num == 0) {
            pthread_mutex_unlock(&mut_num);
            sched_yield();
            pthread_mutex_lock(&mut_num);
        }
        if (num == -1) 
        {
            pthread_mutex_unlock(&mut_num);
            break;
        }
        i = num; // 拿到数据，并且设置为1
        num = 0;
        pthread_mutex_unlock(&mut_num);

        mark = 1;
        for (j = 2;j < i / 2;j++)
        {
            //有一个就进入下一次循环！！
            if (i % j == 0) {
                mark = 0;
                break;
            }
        }
        if (mark)
            printf("[%d]primer is %d\n", n, i);
    }
    pthread_exit(NULL);
}

int main()
{
    int i, err;
    pthread_t tid[THRNUM];
    for (i = 0; i < THRNUM;i++) {
        err = pthread_create(tid + i, NULL, func, (void*)i);
        if (err) {
            fprintf(stderr, "pthread_create():%s\n", strerror(err));
            exit(1);
        }
    }
    for (i = LEFT;i <= RIGHT;i++) {
        pthread_mutex_lock(&mut_num);
        //不等于0 那么就让别人拿去；
        while (num != 0) {
            pthread_mutex_unlock(&mut_num);
            sched_yield();
            pthread_mutex_lock(&mut_num);
        }
        // 已经被取走；
        num = i;
        pthread_mutex_unlock(&mut_num);
    }
    //结束的时候；//标志着线程的结束；
    //收尸的问题；
    //最后一个数字；
    //修改这个数据，都必须是加锁！！！
    pthread_mutex_lock(&mut_num);
    while (num != 0) {
        pthread_mutex_unlock(&mut_num);
        sched_yield();
        pthread_mutex_lock(&mut_num);
    }
    num = -1;
    pthread_mutex_unlock(&mut_num);
    // 收尸    
    for (i = 0; i < THRNUM;i++) {
        pthread_join(tid[i], NULL);
    }

    pthread_mutex_destroy(&mut_num);
    exit(0);
}
``````

