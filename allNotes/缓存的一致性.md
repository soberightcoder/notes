#缓存的一致性

**cache aside 旁路缓存；**

就是先更新数据库再删除缓存；

关于 比较实时性的信息，比如插入到数据库，立马看到效果，直接去去更新缓存就可以了，

下一次请求直接查看缓存；又因为是新用户所有并不存在并发写的问题；





**旁路缓存有一个问题，就是当写入频繁的时候，缓存会被频繁的清除，会对缓存的命中率产生影响；如果你对缓存命中率要求很高可以使用下面的方案**

1. 先更新数据库然后再更新缓存，更新**缓存**的时候加**分布式锁**；

   

2. 先更新数据再更新缓存，但是给**缓存设置过期时间**，出现缓存不一致的问题，缓存过期就会消失，对业务影响可以接受；



![5b5ff7fcd636f7d3a7a0cac659263e8](缓存的一致性.assets/5b5ff7fcd636f7d3a7a0cac659263e8.jpg)





## 一致性哈希问题；



**集群概念：的两种方案**

1. hash 对ID（key）来做hash 然后对hash值取余；

   * 优点：简单 易理解
   * 缺点：当增加和删除节点时，缓存节点个数变化造成缓存失效的问题；

   

2.  一致性哈希算法，**我们将整个hash值空间组成一个虚拟的圆环，然后将缓存节点ip或者主机名hash取值后放在圆环上，**

   **当我们需要确定一个key去那个节点时候，只需要对keyhash取值，确定在换上的位置，然后按照顺时针方向在环上行走，遇到的第一个节点就是要访问的节点；**

   

   * **很好的解决增加和删除节点，命中率下降问题；**

   * 但是还是存在两个问题：

     * **节点在圆环上分布不均匀的问题，会造成部分服务器压力过大；当故障的时，这个节点所承受的所有访问会被瞬移到下一个节点，会对后面的节点造成压力； 可以使用 虚拟节点，它会将一个缓存节点计算多个hash值，分散到圆环的不同位置；**    **当某个服务器故障的时候请求压力就会均匀的分布给其他服务器；**
     * **脏数据；设置过期时间来避免这个脏数据的问题；**

     

**哈希值组成虚拟圆环  顺时针查找；虚拟节点  过期时间**