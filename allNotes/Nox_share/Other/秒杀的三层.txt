秒杀 的 实现

最关键的三点 ，就是秒杀页面要脱离 原先的站点，这里是最重要的 不然 秒杀崩了  主服务器 也就是崩溃了  也就有点得不偿失了，再一点就是 ，页面要实现
再一个点就是 一定要隐藏好你的抢购页面，

做好jsonp的跨域安全的问题  因为肯定是需要多台服务器的肯定是需要 保证跨域的安全性能的 





秒杀其实 就是短时间的高并发，尽量的减少对 数据库的请求，


第一层  就是页面展示  一定要网页静态化 来减少对数据库的请求，给定刷新时间   （这里我用的是 ob 函数来进行网页的静态化）
为了解决地域的问题  是可以使用cdn来进行加速（为了解决地域性的问题 是可以进行cdn 来加速的）

用js 效果来 就是按一下马上变成灰色 来阻挡依稀普通用户的请求 （减少普通用户的请求）





第二层 就是登记层  这里必须是要  如果你想要抢购必须要登记你的信息 还有抢购码  这就是做的第二层的验证  为了防止 一些程序员 进行for 循环的不断 请求  电话号码也是 要做验证的 不能重复   存redis 中  每次 都对电话号码 进行查重  ，当不重复的时候给你生成 抢购码 ，这里是可以使用hash 进行加密的。

这里我用的是hash的求余加密的形式来进行加密的


第三层 也就是开始抢购 这里肯定是要用到了   就是为了防止太多的请求，请求 到数据库，所以就要用到了 队列的机制，我们这里使用zset为了达到去重的目的，我们这里是直接给然后给一个标志位，当标志位也就是他的优先级。


最后一层就是把信息 存到了  数据库。
OSS的机制的实现 ，注意一下。

cdn 加速
引用远程的 js 或者是css 或者是图片，来进行 加速。

在js 中获取时间 也就是 用的是Date来获取的。

要想有统一的时间 必须要获取 服务器的时间

第一次是  获取服务器上面的时间   然后交给 js页面
每次刷新的时候 都重新向服务器 请求 获取浏览器的时间。

页面的倒计时的功能是用 js效果直接写的   直接处理的。
切换页面的时候最好写一个 插件 .sh 也就是 当到了指定的时间的时候 开始
执行插件sh 开始切换页面到展示页面到登陆页面，然后倒计时开始结束的时候
跳转到 抢购的页面。sh 插件的写法 
先写这个，这个就是插件的开始    #!/bin/sh

插件 修改权限 777 也就是可读可写 可执行
也是可以知己。


也是可以在这里写的 也就是  vim /etc/crontab 也就是  可以在里面修改也
会多了那个用户进行调用  
执行任务  这就是秒杀的这一层的设计理念

第一层就是也难展示的页面   用cdn加速来 



第二层 是为了登记用户的 信息，注意在这一层是要把数据提交到第三层的
也就是要用到ajax 但是第三层的抢购页面，肯定不是在同一个服务器 
或者是肯定不是和主站是同一个网站，所以这里是需要用到 跨域的问题的。
有域名  协议 或者是接口不同的时候 就会触发跨域的问题

第三层的购买页面
把用户的信息 
memcached 不支持队列集合和有序队列
redis 的队列 list 列表但是可以排序但是不可以去重

集合 就可以了 只需 知道1000个人 不需要1000人的顺序就可以了
或者是1000 个人还要求前100人 那么就需要排序
zadd(); 添加 
//过期时间

商品数量的检测 
就是在插入数据的时候 就是把标志位加1 
也是可以用count 来判断商品数量是否 足够了
当count 就触发 跳到第四层 
也就是 秒杀的结束页面

代码的实现

关键点 redis 的封装
序列号的生成


注意插入数据的时候 给一个标志位并且 当标志为等于
要求的数目的时候，也就是给要求说 已经超出数量了
。
然后用的是zrange（$this-key,0,-1）//也就是返回所有的数据

// 注意这里电话号码 当用的是 int的形式的时候  是超过
那个int范围的，所以需要float的形式，来正好满足要求。

//注意这个三目运算符的  这里是很好的判断的多看别人 的代码

再一个就是 isset($_GET[number'])?$_GET['number']:0  // 三目当不存在的时候是0


mysql 也是有消息 队列的但是没有 nosql的效率高 所以
就用了redis 来处理



第四层的结束页面   
// 其实就是一个 把nosql 中的数据 转换成 mysql 中的数据就可以了
只需要phone number 和id 就可以了  也就是用户的id 。


为什么 ajax 存在跨域问题
就是为了方式CSRF 攻击     也就是为了CSRF攻击 
就是为了保证网站的安全 
为了防止 恶意网站的ajax 来请求数据 把我们保存的cookie的密码银行密码 
传给取回去 这就会构成了 CSRF的攻击 


  ● DOM同源策略：禁止对不同源页面DOM进行操作
  ● XmlHttpRequest同源策略：禁止向不同源的地址发起HTTP请求
AJAX同源策略主要用来防止CSRF攻击。如果没有AJAX同源策略，攻击过程如下：
我们发起的每一次HTTP请求都会全额发送request地址对应的cookie，那么
  1. 用户登录了自己的银行页面http://MyBank.com，http://MyBank.com向用户的cookie中添加用户标识
  2. 用户浏览了恶意页面 http://Evil.com。执行了页面中的恶意AJAX请求代码
  3. http://Evil.com向http://MyBank.com发起AJAX HTTP请求，请求同时http://MyBank.com对应cookie也同时发送过去
  4. 银行页面从发送的cookie中提取用户标识，验证用户标识无误，response中返回请求数据。此时数据泄露。
  5. 由于Ajax的后台执行，此时用户没有意识这一过程。

所以为了解决 跨域的问题  所以我们先修改了 

header头的内容 

header("Acess-Control-Allow-Origin:http://www.miaosha_levele2.com")

//或者使用jsonp 来进行验证   来防止 CSRF攻击    来限制ajax 的http的请求 


注意这里的 秒杀的实现 

 注意点：一定要脱离原站点，做好预测和压力测试 监控

关键点：保证高可用和双活高并发和数据的过滤
也即是说 用集群来达到 处理高并发  用